<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Is It a Bird? - CLIP Bird Detector</title>
  <script defer data-domain="tools.simonwillison.net" src="https://plausible.io/js/script.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      transition: background-color 0.5s ease;
      line-height: 1.5;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
    }
    h1 {
      margin-top: 0;
    }
    .dropzone {
      width: 100%;
      min-height: 200px;
      border: 3px dashed #666;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      padding: 20px;
      text-align: center;
      transition: border-color 0.2s, background-color 0.2s;
      margin-bottom: 20px;
    }
    .dropzone:hover {
      border-color: #333;
      background-color: rgba(0, 0, 0, 0.05);
    }
    .dropzone.drag-over {
      border-color: #0066cc;
      background-color: rgba(0, 102, 204, 0.1);
    }
    .dropzone.disabled {
      cursor: wait;
      opacity: 0.7;
    }
    .dropzone-text {
      font-size: 18px;
      color: #444;
    }
    .dropzone-hint {
      font-size: 14px;
      color: #888;
      margin-top: 8px;
    }
    #file-input {
      display: none;
    }
    #preview {
      max-width: 100%;
      max-height: 400px;
      border-radius: 8px;
      display: none;
      margin-bottom: 20px;
    }
    #result {
      font-size: 32px;
      font-weight: bold;
      text-align: center;
      padding: 20px;
      border-radius: 12px;
      display: none;
    }
    #score-details {
      text-align: center;
      margin-top: 10px;
      font-size: 14px;
      color: #555;
    }
    #loading {
      text-align: center;
      padding: 20px;
      display: none;
    }
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #ddd;
      border-top-color: #333;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #model-status {
      text-align: center;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 8px;
      background: #fff3cd;
      color: #856404;
      font-weight: bold;
      font-size: 16px;
    }
    #model-status.pending {
      background: #e7f1ff;
      color: #004085;
    }
    #model-status.loading {
      background: #fff3cd;
      color: #856404;
    }
    #model-status.ready {
      background: #d4edda;
      color: #155724;
    }
    #model-status.error {
      background: #f8d7da;
      color: #721c24;
    }
    #load-model-btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      margin-top: 10px;
    }
    #load-model-btn:hover {
      background: #0056b3;
    }
    #model-status .spinner-inline {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #856404;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      vertical-align: middle;
      margin-right: 8px;
    }
    .progress-container {
      width: 100%;
      height: 8px;
      background: rgba(0, 0, 0, 0.1);
      border-radius: 4px;
      margin-top: 10px;
      overflow: hidden;
    }
    .progress-bar {
      height: 100%;
      background: #856404;
      border-radius: 4px;
      transition: width 0.2s ease;
      width: 0%;
    }
    #model-status.ready .progress-container {
      display: none;
    }
    .progress-text {
      font-size: 12px;
      margin-top: 5px;
      font-weight: normal;
    }
    .footer {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #ddd;
      font-size: 14px;
      color: #666;
    }
    .footer a {
      color: #0066cc;
    }

    /* Mode toggle buttons */
    .mode-toggle {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    .mode-btn {
      flex: 1;
      padding: 12px 20px;
      border: 2px solid #666;
      background: white;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }
    .mode-btn:hover {
      border-color: #333;
      background: #f5f5f5;
    }
    .mode-btn.active {
      background: #007bff;
      border-color: #007bff;
      color: white;
    }

    /* Webcam container */
    .webcam-container {
      display: none;
      width: 100%;
      margin-bottom: 20px;
    }
    .webcam-container.active {
      display: block;
    }
    #webcam-video {
      width: 100%;
      max-height: 400px;
      border-radius: 8px;
      background: #000;
      object-fit: cover;
    }
    .webcam-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .webcam-btn {
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .webcam-btn.start {
      background: #28a745;
      color: white;
    }
    .webcam-btn.start:hover {
      background: #218838;
    }
    .webcam-btn.stop {
      background: #dc3545;
      color: white;
    }
    .webcam-btn.stop:hover {
      background: #c82333;
    }
    .webcam-btn.switch {
      background: #6c757d;
      color: white;
    }
    .webcam-btn.switch:hover {
      background: #5a6268;
    }
    .webcam-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .webcam-status {
      text-align: center;
      padding: 10px;
      font-size: 14px;
      color: #666;
    }
    .webcam-placeholder {
      width: 100%;
      height: 300px;
      background: #f0f0f0;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #666;
    }
    .webcam-placeholder-icon {
      font-size: 48px;
      margin-bottom: 10px;
    }

    /* Bird detected - green theme */
    body.is-bird {
      background-color: #90EE90;
    }
    body.is-bird #result {
      background-color: rgba(0, 128, 0, 0.2);
      color: #006400;
    }

    /* Not a bird - neutral/red theme */
    body.not-bird {
      background-color: #FFB6C1;
    }
    body.not-bird #result {
      background-color: rgba(220, 20, 60, 0.2);
      color: #8B0000;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Is It a Bird?</h1>
    <p>Drop, paste, or select an image to find out if it contains a bird using <a href="https://huggingface.co/docs/transformers.js">Transformers.js</a> and OpenAI's CLIP model.</p>

    <div id="model-status" class="pending">
      <div id="pending-message">CLIP model required (~150 MB download)</div>
      <button id="load-model-btn">Load 150 MB model</button>
      <div id="loading-ui" style="display: none;">
        <div><span class="spinner-inline"></span><span id="status-text">Loading CLIP model...</span></div>
        <div class="progress-container"><div class="progress-bar" id="progress-bar"></div></div>
        <div class="progress-text" id="progress-text"></div>
      </div>
    </div>

    <div class="mode-toggle">
      <button class="mode-btn active" id="image-mode-btn">ðŸ“· Image</button>
      <button class="mode-btn" id="webcam-mode-btn">ðŸ“¹ Webcam</button>
    </div>

    <input type="file" id="file-input" accept="image/*">
    <div class="dropzone" id="dropzone">
      <div class="dropzone-text">Drop an image here or click to select</div>
      <div class="dropzone-hint">You can also paste an image from your clipboard (Ctrl/Cmd+V)</div>
    </div>

    <div class="webcam-container" id="webcam-container">
      <div class="webcam-placeholder" id="webcam-placeholder">
        <div class="webcam-placeholder-icon">ðŸ“¹</div>
        <div>Click "Start Camera" to begin</div>
      </div>
      <video id="webcam-video" autoplay playsinline style="display: none;"></video>
      <div class="webcam-controls">
        <button class="webcam-btn start" id="start-camera-btn">Start Camera</button>
        <button class="webcam-btn stop" id="stop-camera-btn" style="display: none;">Stop Camera</button>
        <button class="webcam-btn switch" id="switch-camera-btn" style="display: none;">Switch Camera</button>
      </div>
      <div class="webcam-status" id="webcam-status"></div>
    </div>

    <img id="preview" alt="Preview of uploaded image">

    <div id="loading">
      <div class="spinner"></div>
      <div>Analyzing image with CLIP...</div>
    </div>

    <div id="result"></div>
    <div id="score-details"></div>

    <div class="footer">
      <p>This tool runs entirely in your browser using the <a href="https://huggingface.co/Xenova/clip-vit-base-patch32">Xenova/clip-vit-base-patch32</a> model. No images are uploaded to any server.</p>
      <p>Uses a threshold of 0.5 to determine if something is "likely a bird". The model compares the image against candidate labels: bird, animal, object, person, landscape.</p>
      <p><a href="https://xkcd.com/1425/" style="color: #999; text-decoration: none; font-size: 12px;">Relevant xkcd</a></p>
    </div>
  </div>

  <script type="module">
    import { pipeline } from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.0.2';

    const BIRD_THRESHOLD = 0.5;
    const CANDIDATE_LABELS = ['bird', 'animal', 'object', 'person', 'landscape'];

    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('file-input');
    const preview = document.getElementById('preview');
    const result = document.getElementById('result');
    const scoreDetails = document.getElementById('score-details');
    const loading = document.getElementById('loading');
    const modelStatus = document.getElementById('model-status');
    const statusText = document.getElementById('status-text');
    const progressBar = document.getElementById('progress-bar');
    const progressText = document.getElementById('progress-text');
    const loadModelBtn = document.getElementById('load-model-btn');
    const pendingMessage = document.getElementById('pending-message');
    const loadingUI = document.getElementById('loading-ui');

    // Mode toggle elements
    const imageModeBtn = document.getElementById('image-mode-btn');
    const webcamModeBtn = document.getElementById('webcam-mode-btn');
    const webcamContainer = document.getElementById('webcam-container');

    // Webcam elements
    const webcamVideo = document.getElementById('webcam-video');
    const webcamPlaceholder = document.getElementById('webcam-placeholder');
    const startCameraBtn = document.getElementById('start-camera-btn');
    const stopCameraBtn = document.getElementById('stop-camera-btn');
    const switchCameraBtn = document.getElementById('switch-camera-btn');
    const webcamStatus = document.getElementById('webcam-status');

    let classifier = null;
    let isProcessing = false;
    let isModelLoading = false;
    let pendingImage = null;
    let currentMode = 'image'; // 'image' or 'webcam'
    let webcamStream = null;
    let webcamInterval = null;
    let currentFacingMode = 'environment'; // 'environment' (rear) or 'user' (front)
    let hasMultipleCameras = false;

    // Track progress across multiple files
    const fileProgress = {};

    function updateProgress(data) {
      if (data.status === 'progress') {
        fileProgress[data.file] = { loaded: data.loaded, total: data.total };

        // Calculate overall progress
        let totalLoaded = 0;
        let totalSize = 0;
        for (const file of Object.values(fileProgress)) {
          totalLoaded += file.loaded;
          totalSize += file.total;
        }

        const percent = totalSize > 0 ? (totalLoaded / totalSize) * 100 : 0;
        progressBar.style.width = `${percent}%`;

        // Format bytes for display
        const loadedMB = (totalLoaded / 1024 / 1024).toFixed(1);
        const totalMB = (totalSize / 1024 / 1024).toFixed(1);
        progressText.textContent = `${loadedMB} MB / ${totalMB} MB (${percent.toFixed(0)}%)`;
      } else if (data.status === 'initiate') {
        statusText.textContent = `Loading ${data.file}...`;
      }
    }

    // Load the CLIP model
    async function loadModel() {
      if (isModelLoading || classifier) return;
      isModelLoading = true;

      // Switch to loading UI
      modelStatus.className = 'loading';
      pendingMessage.style.display = 'none';
      loadModelBtn.style.display = 'none';
      loadingUI.style.display = 'block';

      try {
        classifier = await pipeline('zero-shot-image-classification', 'Xenova/clip-vit-base-patch32', {
          progress_callback: updateProgress
        });
        modelStatus.innerHTML = 'CLIP model loaded and ready!';
        modelStatus.className = 'ready';

        // If there's a pending image, classify it now
        if (pendingImage) {
          const imageToClassify = pendingImage;
          pendingImage = null;
          classifyImage(imageToClassify);
        }
      } catch (error) {
        console.error('Failed to load model:', error);
        modelStatus.innerHTML = 'Failed to load model. Please refresh the page.';
        modelStatus.className = 'error';
        isModelLoading = false;
      }
    }

    // Load model button click handler
    loadModelBtn.addEventListener('click', loadModel);

    // Classify an image
    async function classifyImage(imageSource) {
      // If model isn't ready yet, queue the image and start loading
      if (!classifier) {
        pendingImage = imageSource;
        if (!isModelLoading) {
          loadModel();
        }
        statusText.textContent = 'Loading model... your image will be analyzed automatically';
        return;
      }

      if (isProcessing) return;
      isProcessing = true;

      // Reset UI
      document.body.classList.remove('is-bird', 'not-bird');
      result.style.display = 'none';
      scoreDetails.textContent = '';
      loading.style.display = 'block';
      dropzone.classList.add('disabled');

      try {
        const output = await classifier(imageSource, CANDIDATE_LABELS);

        // Find the bird score
        const birdResult = output.find(item => item.label === 'bird');
        const birdScore = birdResult ? birdResult.score : 0;

        // Determine if it's a bird
        const isBird = birdScore >= BIRD_THRESHOLD;

        // Update UI
        loading.style.display = 'none';
        result.style.display = 'block';

        if (isBird) {
          document.body.classList.add('is-bird');
          result.textContent = 'ðŸ¦ Yes, it\'s a bird!';
        } else {
          document.body.classList.add('not-bird');
          result.textContent = 'âŒ Not a bird';
        }

        // Show detailed scores
        const sortedResults = output.sort((a, b) => b.score - a.score);
        const scoresText = sortedResults
          .map(item => `${item.label}: ${(item.score * 100).toFixed(1)}%`)
          .join(' | ');
        scoreDetails.textContent = scoresText;

      } catch (error) {
        console.error('Classification error:', error);
        loading.style.display = 'none';
        result.style.display = 'block';
        result.textContent = 'Error analyzing image';
        document.body.classList.add('not-bird');
      }

      isProcessing = false;
      dropzone.classList.remove('disabled');
    }

    // Handle file selection
    function handleFile(file) {
      if (!file || !file.type.startsWith('image/')) {
        alert('Please select an image file.');
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        const dataUrl = e.target.result;
        preview.src = dataUrl;
        preview.style.display = 'block';
        classifyImage(dataUrl);
      };
      reader.readAsDataURL(file);
    }

    // Dropzone events
    dropzone.addEventListener('click', () => {
      if (!isProcessing) {
        fileInput.click();
      }
    });

    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      if (!isProcessing) {
        dropzone.classList.add('drag-over');
      }
    });

    dropzone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropzone.classList.remove('drag-over');
    });

    dropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropzone.classList.remove('drag-over');
      if (!isProcessing && e.dataTransfer.files.length > 0) {
        handleFile(e.dataTransfer.files[0]);
      }
    });

    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        handleFile(e.target.files[0]);
      }
    });

    // Paste support
    document.addEventListener('paste', (e) => {
      const items = e.clipboardData?.items;
      if (!items) return;

      for (const item of items) {
        if (item.type.startsWith('image/')) {
          const file = item.getAsFile();
          if (file) {
            handleFile(file);
            break;
          }
        }
      }
    });

    // Mode toggle handlers
    function setMode(mode) {
      currentMode = mode;

      if (mode === 'image') {
        imageModeBtn.classList.add('active');
        webcamModeBtn.classList.remove('active');
        dropzone.style.display = 'flex';
        webcamContainer.classList.remove('active');
        stopWebcam();
      } else {
        webcamModeBtn.classList.add('active');
        imageModeBtn.classList.remove('active');
        dropzone.style.display = 'none';
        preview.style.display = 'none';
        webcamContainer.classList.add('active');
        // Reset result when switching to webcam
        document.body.classList.remove('is-bird', 'not-bird');
        result.style.display = 'none';
        scoreDetails.textContent = '';
      }
    }

    imageModeBtn.addEventListener('click', () => setMode('image'));
    webcamModeBtn.addEventListener('click', () => setMode('webcam'));

    // Check for multiple cameras
    async function checkCameras() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(d => d.kind === 'videoinput');
        hasMultipleCameras = videoDevices.length > 1;
      } catch (e) {
        console.log('Could not enumerate devices:', e);
      }
    }

    // Start webcam
    async function startWebcam() {
      try {
        webcamStatus.textContent = 'Requesting camera access...';

        const constraints = {
          video: {
            facingMode: currentFacingMode,
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        };

        webcamStream = await navigator.mediaDevices.getUserMedia(constraints);
        webcamVideo.srcObject = webcamStream;

        webcamVideo.style.display = 'block';
        webcamPlaceholder.style.display = 'none';
        startCameraBtn.style.display = 'none';
        stopCameraBtn.style.display = 'inline-block';

        await checkCameras();
        if (hasMultipleCameras) {
          switchCameraBtn.style.display = 'inline-block';
        }

        webcamStatus.textContent = 'Camera active - analyzing every 500ms...';

        // Start loading model if not loaded
        if (!classifier && !isModelLoading) {
          loadModel();
        }

        // Start the classification loop
        startClassificationLoop();

      } catch (error) {
        console.error('Camera error:', error);
        webcamStatus.textContent = `Camera error: ${error.message}`;
      }
    }

    // Stop webcam
    function stopWebcam() {
      if (webcamInterval) {
        clearInterval(webcamInterval);
        webcamInterval = null;
      }

      if (webcamStream) {
        webcamStream.getTracks().forEach(track => track.stop());
        webcamStream = null;
      }

      webcamVideo.srcObject = null;
      webcamVideo.style.display = 'none';
      webcamPlaceholder.style.display = 'flex';
      startCameraBtn.style.display = 'inline-block';
      stopCameraBtn.style.display = 'none';
      switchCameraBtn.style.display = 'none';
      webcamStatus.textContent = '';
    }

    // Switch camera
    async function switchCamera() {
      currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
      stopWebcam();
      await startWebcam();
    }

    // Capture frame from video
    function captureFrame() {
      const canvas = document.createElement('canvas');
      canvas.width = webcamVideo.videoWidth;
      canvas.height = webcamVideo.videoHeight;

      if (canvas.width === 0 || canvas.height === 0) {
        return null;
      }

      const ctx = canvas.getContext('2d');
      ctx.drawImage(webcamVideo, 0, 0, canvas.width, canvas.height);
      return canvas.toDataURL('image/jpeg', 0.8);
    }

    // Classify webcam frame (non-blocking for continuous updates)
    async function classifyWebcamFrame() {
      if (!classifier || isProcessing) return;

      const imageData = captureFrame();
      if (!imageData) return;

      isProcessing = true;

      try {
        const output = await classifier(imageData, CANDIDATE_LABELS);

        // Find the bird score
        const birdResult = output.find(item => item.label === 'bird');
        const birdScore = birdResult ? birdResult.score : 0;

        // Determine if it's a bird
        const isBird = birdScore >= BIRD_THRESHOLD;

        // Update UI
        loading.style.display = 'none';
        result.style.display = 'block';

        document.body.classList.remove('is-bird', 'not-bird');
        if (isBird) {
          document.body.classList.add('is-bird');
          result.textContent = 'ðŸ¦ Yes, it\'s a bird!';
        } else {
          document.body.classList.add('not-bird');
          result.textContent = 'âŒ Not a bird';
        }

        // Show detailed scores
        const sortedResults = output.sort((a, b) => b.score - a.score);
        const scoresText = sortedResults
          .map(item => `${item.label}: ${(item.score * 100).toFixed(1)}%`)
          .join(' | ');
        scoreDetails.textContent = scoresText;

      } catch (error) {
        console.error('Classification error:', error);
      }

      isProcessing = false;
    }

    // Start classification loop
    function startClassificationLoop() {
      if (webcamInterval) {
        clearInterval(webcamInterval);
      }

      // Run immediately once video is ready
      webcamVideo.addEventListener('loadeddata', () => {
        if (classifier) {
          classifyWebcamFrame();
        }
      }, { once: true });

      // Then run every 500ms
      webcamInterval = setInterval(() => {
        if (webcamStream && classifier) {
          classifyWebcamFrame();
        }
      }, 500);
    }

    // Webcam button handlers
    startCameraBtn.addEventListener('click', startWebcam);
    stopCameraBtn.addEventListener('click', stopWebcam);
    switchCameraBtn.addEventListener('click', switchCamera);
  </script>
</body>
</html>
