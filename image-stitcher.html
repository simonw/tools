<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Image Stitcher</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: system-ui, -apple-system, sans-serif;
  background: #f5f5f5;
  color: #333;
  padding: 20px;
  max-width: 1400px;
  margin: 0 auto;
}
h1 { margin-bottom: 4px; }
.subtitle { color: #666; margin-bottom: 16px; }

/* Drop zone */
#drop-zone {
  border: 2px dashed #bbb;
  border-radius: 12px;
  padding: 40px 20px;
  text-align: center;
  cursor: pointer;
  background: #fff;
  transition: background 0.2s, border-color 0.2s;
  margin-bottom: 20px;
}
#drop-zone.dragover { background: #e8f0fe; border-color: #4285f4; }
#drop-zone p { font-size: 16px; color: #666; }
#drop-zone .hint { font-size: 13px; color: #999; margin-top: 6px; }
.visually-hidden {
  position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
  overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0;
}

/* Toolbar */
.toolbar {
  display: flex; flex-wrap: wrap; gap: 8px; align-items: center;
  margin-bottom: 16px; padding: 12px; background: #fff;
  border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.toolbar button, .toolbar select {
  padding: 6px 14px; border: 1px solid #ccc; border-radius: 6px;
  background: #fff; cursor: pointer; font-size: 14px;
}
.toolbar button:hover { background: #f0f0f0; }
.toolbar button.primary {
  background: #4285f4; color: #fff; border-color: #4285f4;
}
.toolbar button.primary:hover { background: #3367d6; }
.toolbar button.danger { color: #d93025; border-color: #d93025; }
.toolbar button.danger:hover { background: #fce8e6; }

/* Image strips area */
#editor { display: none; }

#strips-container {
  display: flex;
  align-items: flex-start;
  gap: 0;
  overflow-x: auto;
  padding: 20px 0;
  background: repeating-conic-gradient(#e0e0e0 0% 25%, #fff 0% 50%) 50% / 16px 16px;
  border: 1px solid #ddd;
  border-radius: 8px;
  min-height: 200px;
  position: relative;
}

.strip-wrapper {
  position: relative;
  flex-shrink: 0;
  cursor: grab;
  user-select: none;
  -webkit-user-select: none;
  touch-action: none;
}
.strip-wrapper.selected { outline: 3px solid #4285f4; outline-offset: -3px; z-index: 2; }
.strip-wrapper.dragging { cursor: grabbing; opacity: 0.9; }
.strip-wrapper img {
  display: block;
  max-height: 500px;
  pointer-events: none;
}
.strip-label {
  position: absolute; top: 4px; left: 4px;
  background: rgba(0,0,0,0.6); color: #fff;
  font-size: 11px; padding: 2px 8px; border-radius: 4px;
  pointer-events: none;
}
.strip-reorder {
  position: absolute; top: 4px; right: 4px;
  display: flex; gap: 2px;
}
.strip-reorder button {
  background: rgba(0,0,0,0.6); color: #fff; border: none;
  width: 24px; height: 24px; border-radius: 4px; cursor: pointer;
  font-size: 14px; line-height: 1; display: flex; align-items: center; justify-content: center;
}
.strip-reorder button:hover { background: rgba(0,0,0,0.8); }

/* Nudge controls */
#nudge-controls {
  display: flex; flex-wrap: wrap; gap: 8px; align-items: center;
  margin-bottom: 16px; padding: 10px 12px;
  background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
#nudge-controls span { font-size: 14px; color: #555; }
#nudge-controls button {
  padding: 6px 12px; border: 1px solid #ccc; border-radius: 6px;
  background: #fff; cursor: pointer; font-size: 14px;
}
#nudge-controls button:hover { background: #f0f0f0; }
#selected-name { font-weight: 600; color: #333; }

/* Overlap zoom */
#overlap-section { display: none; margin-bottom: 20px; }
#overlap-section h3 { margin-bottom: 8px; font-size: 15px; color: #555; }
#overlap-panels {
  display: flex; gap: 16px; overflow-x: auto; padding-bottom: 8px;
}
.overlap-panel {
  flex-shrink: 0;
  background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  padding: 8px; min-width: 200px;
}
.overlap-panel .label {
  font-size: 12px; color: #666; margin-bottom: 6px; text-align: center;
}
.overlap-canvas-wrap {
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: repeating-conic-gradient(#e0e0e0 0% 25%, #fff 0% 50%) 50% / 10px 10px;
  max-height: 500px;
}
.overlap-canvas-wrap canvas { display: block; }

/* Result */
#result-section {
  display: none;
  margin-top: 24px;
  padding: 16px;
  background: #fff;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
#result-section h3 { margin-bottom: 12px; }
#result-container {
  overflow-x: auto;
  background: repeating-conic-gradient(#e0e0e0 0% 25%, #fff 0% 50%) 50% / 16px 16px;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 8px;
}
#result-canvas { max-width: 100%; height: auto; }
#result-info { font-size: 13px; color: #666; margin-top: 8px; }

.export-row {
  display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-top: 12px;
}
.export-row button {
  padding: 8px 16px; border: 1px solid #ccc; border-radius: 6px;
  background: #fff; cursor: pointer; font-size: 14px;
}
.export-row button:hover { background: #f0f0f0; }
.export-row button.primary { background: #4285f4; color: #fff; border-color: #4285f4; }
.export-row button.primary:hover { background: #3367d6; }
.export-row label { font-size: 14px; }
.export-row input[type=range] { width: 100px; }
#quality-val { font-size: 13px; color: #666; }

@media (max-width: 600px) {
  body { padding: 10px; }
  .toolbar, #nudge-controls { gap: 4px; padding: 8px; }
  .toolbar button, .toolbar select, #nudge-controls button { padding: 6px 8px; font-size: 13px; }
  #overlap-panels { flex-direction: column; }
}
</style>
</head>
<body>

<h1>Image Stitcher</h1>
<p class="subtitle">Horizontally stitch multiple images with adjustable vertical alignment</p>

<label id="drop-zone" for="file-input">
  <div>
    <p>Drop images here or click to select</p>
    <p class="hint">Supports PNG, JPEG, WebP, GIF &mdash; drag to adjust, arrow keys to nudge</p>
  </div>
  <input id="file-input" class="visually-hidden" type="file" multiple accept="image/*">
</label>

<div id="editor">
  <div class="toolbar">
    <button id="btn-add" title="Add more images">+ Add Images</button>
    <button id="btn-auto-align">Auto Align</button>
    <button id="btn-reset-offsets">Reset Offsets</button>
    <button class="danger" id="btn-remove-selected">Remove Selected</button>
    <button class="danger" id="btn-clear-all">Clear All</button>
  </div>

  <div id="nudge-controls">
    <span>Selected: <strong id="selected-name">None</strong></span>
    <button id="btn-up" title="Move up 1px">&#9650; Up</button>
    <button id="btn-down" title="Move down 1px">&#9660; Down</button>
    <button id="btn-up10" title="Move up 10px">&#9650;&#9650; Up 10</button>
    <button id="btn-down10" title="Move down 10px">&#9660;&#9660; Down 10</button>
  </div>

  <div id="strips-container"></div>

  <div id="overlap-section">
    <h3>Overlap Previews (seam areas between adjacent images)</h3>
    <div id="overlap-panels"></div>
  </div>

  <div id="result-section">
    <h3>Stitched Result</h3>
    <div id="result-container">
      <canvas id="result-canvas"></canvas>
    </div>
    <div id="result-info"></div>
    <div class="export-row">
      <button class="primary" id="btn-export-png">Export PNG</button>
      <button id="btn-export-jpeg">Export JPEG</button>
      <label>Quality: <input type="range" id="jpeg-quality" min="10" max="100" value="92" step="1"></label>
      <span id="quality-val">92%</span>
    </div>
  </div>
</div>

<script>
(function() {
  'use strict';

  // State
  const images = []; // {id, name, img, offsetY, naturalW, naturalH}
  let selectedId = null;
  let idCounter = 0;
  const OVERLAP_PX = 60; // pixels from each side to show in overlap preview
  const ZOOM_FACTOR = 3;

  // DOM refs
  const dropZone = document.getElementById('drop-zone');
  const fileInput = document.getElementById('file-input');
  const editor = document.getElementById('editor');
  const stripsContainer = document.getElementById('strips-container');
  const overlapSection = document.getElementById('overlap-section');
  const overlapPanels = document.getElementById('overlap-panels');
  const resultSection = document.getElementById('result-section');
  const resultCanvas = document.getElementById('result-canvas');
  const resultInfo = document.getElementById('result-info');
  const selectedNameEl = document.getElementById('selected-name');
  const qualitySlider = document.getElementById('jpeg-quality');
  const qualityVal = document.getElementById('quality-val');

  // --- Event listeners ---

  fileInput.addEventListener('change', e => { loadFiles(e.target.files); e.target.value = ''; });
  dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
  dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
  dropZone.addEventListener('drop', e => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    loadFiles(e.dataTransfer.files);
  });

  document.getElementById('btn-add').addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file'; input.multiple = true; input.accept = 'image/*';
    input.addEventListener('change', e => loadFiles(e.target.files));
    input.click();
  });

  document.getElementById('btn-auto-align').addEventListener('click', autoAlign);
  document.getElementById('btn-reset-offsets').addEventListener('click', () => {
    images.forEach(im => im.offsetY = 0);
    render();
  });
  document.getElementById('btn-remove-selected').addEventListener('click', () => {
    if (selectedId == null) return;
    const idx = images.findIndex(im => im.id === selectedId);
    if (idx >= 0) images.splice(idx, 1);
    selectedId = images.length > 0 ? images[0].id : null;
    render();
    if (images.length === 0) editor.style.display = 'none';
  });
  document.getElementById('btn-clear-all').addEventListener('click', () => {
    images.length = 0;
    selectedId = null;
    editor.style.display = 'none';
    render();
  });

  document.getElementById('btn-up').addEventListener('click', () => nudge(-1));
  document.getElementById('btn-down').addEventListener('click', () => nudge(1));
  document.getElementById('btn-up10').addEventListener('click', () => nudge(-10));
  document.getElementById('btn-down10').addEventListener('click', () => nudge(10));

  qualitySlider.addEventListener('input', () => {
    qualityVal.textContent = qualitySlider.value + '%';
  });

  document.getElementById('btn-export-png').addEventListener('click', () => doExport('png'));
  document.getElementById('btn-export-jpeg').addEventListener('click', () => doExport('jpeg'));

  // Keyboard: arrow keys nudge selected image
  document.addEventListener('keydown', e => {
    if (selectedId == null) return;
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    if (e.key === 'ArrowUp') { e.preventDefault(); nudge(e.shiftKey ? -10 : -1); }
    if (e.key === 'ArrowDown') { e.preventDefault(); nudge(e.shiftKey ? 10 : 1); }
    if (e.key === 'Delete' || e.key === 'Backspace') {
      e.preventDefault();
      document.getElementById('btn-remove-selected').click();
    }
  });

  // --- Core functions ---

  function nudge(dy) {
    const im = images.find(im => im.id === selectedId);
    if (!im) return;
    im.offsetY += dy;
    render();
  }

  function loadFiles(files) {
    if (!files || files.length === 0) return;
    let loaded = 0;
    const toLoad = Array.from(files).filter(f => f.type.startsWith('image/')).length;
    if (toLoad === 0) return;

    Array.from(files).forEach(file => {
      if (!file.type.startsWith('image/')) return;
      const reader = new FileReader();
      reader.onload = e => {
        const img = new Image();
        img.onload = () => {
          images.push({
            id: idCounter++,
            name: file.name,
            img,
            offsetY: 0,
            naturalW: img.naturalWidth,
            naturalH: img.naturalHeight,
          });
          loaded++;
          if (loaded === toLoad) {
            if (selectedId == null && images.length > 0) selectedId = images[0].id;
            if (images.length > 1) autoAlign();
            else render();
          }
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    });
    editor.style.display = 'block';
  }

  // --- Auto-align using edge luminance cross-correlation ---

  function autoAlign() {
    if (images.length < 2) { render(); return; }
    images[0].offsetY = 0;

    for (let i = 1; i < images.length; i++) {
      const prev = images[i - 1];
      const curr = images[i];
      const bestShift = findBestVerticalOffset(prev, curr);
      curr.offsetY = prev.offsetY + bestShift;
    }

    // Normalize so minimum offsetY is 0
    const minOff = Math.min(...images.map(im => im.offsetY));
    images.forEach(im => im.offsetY -= minOff);
    render();
  }

  function findBestVerticalOffset(imgA, imgB) {
    const sampleW = 8;
    const hA = imgA.naturalH;
    const hB = imgB.naturalH;

    // Sample right edge of A
    const cA = document.createElement('canvas');
    cA.width = sampleW; cA.height = hA;
    const ctxA = cA.getContext('2d', { willReadFrequently: true });
    ctxA.drawImage(imgA.img, imgA.naturalW - sampleW, 0, sampleW, hA, 0, 0, sampleW, hA);
    const dataA = ctxA.getImageData(0, 0, sampleW, hA).data;

    // Sample left edge of B
    const cB = document.createElement('canvas');
    cB.width = sampleW; cB.height = hB;
    const ctxB = cB.getContext('2d', { willReadFrequently: true });
    ctxB.drawImage(imgB.img, 0, 0, sampleW, hB, 0, 0, sampleW, hB);
    const dataB = ctxB.getImageData(0, 0, sampleW, hB).data;

    // Compute luminance average per row
    function rowLuminance(data, w, h) {
      const out = new Float32Array(h);
      for (let y = 0; y < h; y++) {
        let sum = 0;
        for (let x = 0; x < w; x++) {
          const i = (y * w + x) * 4;
          sum += data[i] * 0.299 + data[i+1] * 0.587 + data[i+2] * 0.114;
        }
        out[y] = sum / w;
      }
      return out;
    }

    const lumA = rowLuminance(dataA, sampleW, hA);
    const lumB = rowLuminance(dataB, sampleW, hB);

    // Cross-correlate: shift = how much B is shifted down relative to A
    // A row y aligns with B row (y - shift)
    const maxShift = Math.max(Math.floor(Math.max(hA, hB) * 0.5), 50);
    let bestScore = Infinity;
    let bestShift = 0;
    const minOverlap = Math.min(hA, hB) * 0.2;

    for (let shift = -maxShift; shift <= maxShift; shift++) {
      let sse = 0;
      let count = 0;
      for (let y = 0; y < hA; y++) {
        const yB = y - shift;
        if (yB < 0 || yB >= hB) continue;
        const d = lumA[y] - lumB[yB];
        sse += d * d;
        count++;
      }
      if (count < minOverlap) continue;
      const mse = sse / count;
      if (mse < bestScore) { bestScore = mse; bestShift = shift; }
    }

    return bestShift;
  }

  // --- Rendering ---

  function render() {
    renderStrips();
    renderOverlaps();
    renderResult();
    updateSelectionLabel();
  }

  function updateSelectionLabel() {
    const im = images.find(im => im.id === selectedId);
    selectedNameEl.textContent = im ? im.name + ' (y: ' + im.offsetY + ')' : 'None';
  }

  function getDisplayScale() {
    if (images.length === 0) return 1;
    const maxH = Math.max(...images.map(im => im.naturalH));
    const targetH = Math.min(400, window.innerHeight * 0.4);
    return Math.min(1, targetH / maxH);
  }

  function renderStrips() {
    stripsContainer.innerHTML = '';
    if (images.length === 0) return;

    const scale = getDisplayScale();

    // Vertical range across all images
    let minY = Infinity, maxY = -Infinity;
    images.forEach(im => {
      minY = Math.min(minY, im.offsetY);
      maxY = Math.max(maxY, im.offsetY + im.naturalH);
    });

    images.forEach((im, idx) => {
      const wrapper = document.createElement('div');
      wrapper.className = 'strip-wrapper' + (im.id === selectedId ? ' selected' : '');
      wrapper.dataset.id = im.id;
      wrapper.style.marginTop = ((im.offsetY - minY) * scale) + 'px';

      const imgEl = document.createElement('img');
      imgEl.src = im.img.src;
      imgEl.style.height = (im.naturalH * scale) + 'px';
      imgEl.style.width = (im.naturalW * scale) + 'px';
      imgEl.draggable = false;

      const label = document.createElement('div');
      label.className = 'strip-label';
      label.textContent = im.name + ' (y: ' + im.offsetY + ')';

      // Reorder buttons
      const reorderDiv = document.createElement('div');
      reorderDiv.className = 'strip-reorder';
      if (idx > 0) {
        const btn = document.createElement('button');
        btn.textContent = '\u25C0';
        btn.title = 'Move left';
        btn.addEventListener('click', e => { e.stopPropagation(); swapImages(idx, idx - 1); });
        reorderDiv.appendChild(btn);
      }
      if (idx < images.length - 1) {
        const btn = document.createElement('button');
        btn.textContent = '\u25B6';
        btn.title = 'Move right';
        btn.addEventListener('click', e => { e.stopPropagation(); swapImages(idx, idx + 1); });
        reorderDiv.appendChild(btn);
      }

      wrapper.appendChild(imgEl);
      wrapper.appendChild(label);
      wrapper.appendChild(reorderDiv);
      stripsContainer.appendChild(wrapper);

      // Pointer events for selection + drag
      wrapper.addEventListener('pointerdown', e => {
        if (e.target.tagName === 'BUTTON') return;
        selectedId = im.id;
        startDrag(e, im, scale, wrapper);
      });
    });
  }

  function swapImages(i, j) {
    [images[i], images[j]] = [images[j], images[i]];
    render();
  }

  function startDrag(e, im, scale, wrapper) {
    e.preventDefault();
    wrapper.setPointerCapture(e.pointerId);
    wrapper.classList.add('dragging');

    // Update selection visuals immediately
    document.querySelectorAll('.strip-wrapper').forEach(w => w.classList.remove('selected'));
    wrapper.classList.add('selected');
    updateSelectionLabel();

    const startY = e.clientY;
    const startOffset = im.offsetY;

    function onMove(ev) {
      const dy = ev.clientY - startY;
      im.offsetY = startOffset + Math.round(dy / scale);
      renderThrottled();
    }

    function onUp(ev) {
      wrapper.releasePointerCapture(ev.pointerId);
      wrapper.classList.remove('dragging');
      wrapper.removeEventListener('pointermove', onMove);
      wrapper.removeEventListener('pointerup', onUp);
      wrapper.removeEventListener('pointercancel', onUp);
      render();
    }

    wrapper.addEventListener('pointermove', onMove);
    wrapper.addEventListener('pointerup', onUp);
    wrapper.addEventListener('pointercancel', onUp);
  }

  let rafId = null;
  function renderThrottled() {
    if (rafId) return;
    rafId = requestAnimationFrame(() => { rafId = null; render(); });
  }

  // --- Overlap zoom previews ---

  function renderOverlaps() {
    overlapPanels.innerHTML = '';
    if (images.length < 2) {
      overlapSection.style.display = 'none';
      return;
    }
    overlapSection.style.display = 'block';

    for (let i = 0; i < images.length - 1; i++) {
      const left = images[i];
      const right = images[i + 1];

      const panel = document.createElement('div');
      panel.className = 'overlap-panel';

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = (i + 1) + ' \u2194 ' + (i + 2) + ': ' + left.name + ' | ' + right.name;
      panel.appendChild(label);

      const wrap = document.createElement('div');
      wrap.className = 'overlap-canvas-wrap';

      const canvas = document.createElement('canvas');

      // Source regions: right edge of left image, left edge of right image
      const leftSrcX = Math.max(0, left.naturalW - OVERLAP_PX);
      const leftSrcW = left.naturalW - leftSrcX;
      const rightSrcW = Math.min(OVERLAP_PX, right.naturalW);

      // Vertical extent in stitched space
      const minY = Math.min(left.offsetY, right.offsetY);
      const maxY = Math.max(left.offsetY + left.naturalH, right.offsetY + right.naturalH);
      const totalH = maxY - minY;

      // Canvas size: zoomed width, height capped at 500
      const canvasW = (leftSrcW + rightSrcW) * ZOOM_FACTOR;
      const maxCanvasH = 500;
      const canvasH = Math.min(totalH * ZOOM_FACTOR, maxCanvasH);
      const scaleY = canvasH / totalH;

      canvas.width = canvasW;
      canvas.height = canvasH;
      canvas.style.width = canvasW + 'px';
      canvas.style.height = canvasH + 'px';

      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;

      // Draw left image's right edge
      ctx.drawImage(left.img,
        leftSrcX, 0, leftSrcW, left.naturalH,
        0, (left.offsetY - minY) * scaleY,
        leftSrcW * ZOOM_FACTOR, left.naturalH * scaleY
      );

      // Seam line
      const seamX = leftSrcW * ZOOM_FACTOR;
      ctx.save();
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(seamX, 0);
      ctx.lineTo(seamX, canvasH);
      ctx.stroke();
      ctx.restore();

      // Draw right image's left edge
      ctx.drawImage(right.img,
        0, 0, rightSrcW, right.naturalH,
        seamX, (right.offsetY - minY) * scaleY,
        rightSrcW * ZOOM_FACTOR, right.naturalH * scaleY
      );

      wrap.appendChild(canvas);
      panel.appendChild(wrap);
      overlapPanels.appendChild(panel);
    }
  }

  // --- Stitched result ---

  function renderResult() {
    if (images.length === 0) {
      resultSection.style.display = 'none';
      return;
    }
    resultSection.style.display = 'block';

    let totalW = 0;
    let minY = Infinity, maxY = -Infinity;
    images.forEach(im => {
      totalW += im.naturalW;
      minY = Math.min(minY, im.offsetY);
      maxY = Math.max(maxY, im.offsetY + im.naturalH);
    });
    const totalH = maxY - minY;

    resultCanvas.width = totalW;
    resultCanvas.height = totalH;
    const ctx = resultCanvas.getContext('2d');
    ctx.clearRect(0, 0, totalW, totalH);

    let x = 0;
    images.forEach(im => {
      ctx.drawImage(im.img, x, im.offsetY - minY);
      x += im.naturalW;
    });

    resultInfo.textContent = totalW + ' \u00D7 ' + totalH + 'px \u2014 ' + images.length + ' image(s)';
  }

  // --- Export ---

  function doExport(format) {
    if (images.length === 0) return;
    const mime = format === 'jpeg' ? 'image/jpeg' : 'image/png';
    const quality = format === 'jpeg' ? parseInt(qualitySlider.value) / 100 : undefined;
    const ext = format === 'jpeg' ? 'jpg' : 'png';

    resultCanvas.toBlob(blob => {
      if (!blob) return;
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'stitched.' + ext;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 3000);
    }, mime, quality);
  }

})();
</script>
</body>
</html>
