<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blog to Newsletter</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
    }
    h1 {
      margin-top: 0;
      color: #1a1a1a;
    }
    .info {
      background: #f0f7ff;
      border: 1px solid #b8d4ff;
      border-radius: 6px;
      padding: 15px;
      margin-bottom: 20px;
    }
    .info a {
      color: #0066cc;
    }
    .days-since {
      font-size: 1.1em;
      color: #666;
      margin-bottom: 15px;
    }
    .controls {
      background: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .control-group {
      margin-bottom: 15px;
    }
    .control-group:last-child {
      margin-bottom: 0;
    }
    label {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
    }
    input[type="range"] {
      width: 200px;
    }
    input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
    textarea {
      width: 100%;
      height: 100px;
      padding: 10px;
      font-family: inherit;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
    }
    .buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    button {
      padding: 12px 20px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .primary-btn {
      background: #0066cc;
      color: white;
      font-weight: bold;
    }
    .primary-btn:hover {
      background: #0055aa;
    }
    .secondary-btn {
      background: #666;
      color: white;
    }
    .secondary-btn:hover {
      background: #555;
    }
    .html-length {
      color: #666;
      font-size: 0.9em;
      margin-bottom: 10px;
    }
    .status {
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 15px;
    }
    .status.loading {
      background: #fff3cd;
      color: #856404;
    }
    .status.error {
      background: #f8d7da;
      color: #721c24;
    }
    .status.success {
      background: #d4edda;
      color: #155724;
    }
    h2 {
      margin-top: 30px;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }
    h3 {
      margin-top: 20px;
    }
    .story-order {
      margin-bottom: 20px;
    }
    .story-order ul {
      list-style: none;
      padding: 0;
      margin: 10px 0;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
    }
    .story-order li {
      padding: 10px 15px;
      border-bottom: 1px solid #eee;
      cursor: move;
      background: white;
      transition: background-color 0.2s;
    }
    .story-order li:last-child {
      border-bottom: none;
    }
    .story-order li:hover {
      background: #f5f5f5;
    }
    .story-order li.dragging {
      opacity: 0.5;
      background: #e0e0e0;
    }
    .story-order li.drag-over-top {
      border-top: 3px solid #0066cc;
    }
    .story-order li.drag-over-bottom {
      border-bottom: 3px solid #0066cc;
    }
    .newsletter-preview {
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 20px;
      margin-top: 20px;
    }
    .newsletter-preview img {
      max-width: 100%;
      height: auto;
    }
    .newsletter-preview hr {
      border: none;
      border-top: 1px solid #ddd;
      margin: 20px 0;
    }
    .newsletter-preview h3 a {
      color: #0066cc;
      text-decoration: none;
    }
    .newsletter-preview h3 a:hover {
      text-decoration: underline;
    }
    .newsletter-preview blockquote {
      border-left: 4px solid #ddd;
      margin: 10px 0;
      padding: 10px 20px;
      background: #f9f9f9;
    }
    .previous-links {
      margin-top: 30px;
    }
    .previous-links input[type="text"] {
      width: 100%;
      padding: 10px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    .links-table {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .links-table table {
      width: 100%;
      border-collapse: collapse;
    }
    .links-table td {
      padding: 8px 12px;
      border-bottom: 1px solid #eee;
      font-size: 13px;
      word-break: break-all;
    }
    .links-table tr:last-child td {
      border-bottom: none;
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <h1>Blog to Newsletter</h1>

  <div class="info">
    <p>This tool generates HTML from the <a href="https://datasette.simonwillison.net/simonwillisonblog" target="_blank">Datasette backup of simonwillison.net</a> for copying into Substack.</p>
    <p>See: <a href="https://simonwillison.net/2023/Apr/4/substack-observable/" target="_blank">Semi-automating a Substack newsletter with an Observable notebook</a></p>
  </div>

  <div class="days-since" id="daysSince">Loading...</div>

  <div class="controls">
    <div class="control-group">
      <label>
        Last <span id="numDaysValue">7</span> days:
        <input type="range" id="numDays" min="1" max="60" value="7">
      </label>
    </div>
    <div class="control-group">
      <label>
        <input type="checkbox" id="skipExisting" checked>
        Skip content sent in prior newsletters
      </label>
    </div>
    <div class="control-group">
      <label>
        <input type="checkbox" id="onlyPreCutoff" checked>
        Only include post content prior to the cutoff comment
      </label>
    </div>
    <div class="control-group">
      <label for="rssInput">Paste RSS here if Substack feed is unavailable:</label>
      <textarea id="rssInput" placeholder="Paste RSS XML content here (optional)"></textarea>
    </div>
  </div>

  <div id="status" class="status hidden"></div>

  <div class="buttons">
    <button class="primary-btn" id="copyRichText">Copy rich text newsletter to clipboard</button>
    <button class="secondary-btn" id="copyLinksOnly">Copy just the links/quotes/TILs</button>
  </div>

  <div class="html-length" id="htmlLength"></div>

  <div class="story-order" id="storyOrderSection">
    <h3>Set order of the stories:</h3>
    <ul id="storyOrderList"></ul>
  </div>

  <h2>Newsletter preview</h2>
  <div class="newsletter-preview" id="preview"></div>

  <div class="previous-links">
    <h2>Links sent in previous newsletters</h2>
    <input type="text" id="linksSearch" placeholder="Search previous links...">
    <div class="links-table" id="linksTable"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    (async function() {
      // State
      let rawContent = [];
      let content = [];
      let entries = [];
      let blogmarks = [];
      let quotations = [];
      let tils = [];
      let notes = [];
      let previousLinks = [];
      let storyOrder = [];
      let newsletterHTML = '';
      let daysSinceLastNewsletter = 0;

      // DOM elements
      const numDaysInput = document.getElementById('numDays');
      const numDaysValue = document.getElementById('numDaysValue');
      const skipExistingInput = document.getElementById('skipExisting');
      const onlyPreCutoffInput = document.getElementById('onlyPreCutoff');
      const rssInput = document.getElementById('rssInput');
      const statusEl = document.getElementById('status');
      const previewEl = document.getElementById('preview');
      const htmlLengthEl = document.getElementById('htmlLength');
      const storyOrderList = document.getElementById('storyOrderList');
      const storyOrderSection = document.getElementById('storyOrderSection');
      const linksSearch = document.getElementById('linksSearch');
      const linksTable = document.getElementById('linksTable');
      const daysSinceEl = document.getElementById('daysSince');

      // SQL query
      const sql = `
with content as (
  select
    id,
    'entry' as type,
    title,
    created,
    slug,
    '<h3><a href="' || 'https://simonwillison.net/' || strftime('%Y/', created)
      || substr('JanFebMarAprMayJunJulAugSepOctNovDec', (strftime('%m', created) - 1) * 3 + 1, 3)
      || '/' || cast(strftime('%d', created) as integer) || '/' || slug || '/' || '">'
      || title || '</a> - ' || date(created) || '</h3>' || body
      as html,
    'null' as json,
    '' as external_url
  from blog_entry
  union all
  select
    id,
    'blogmark' as type,
    link_title,
    created,
    slug,
    '<p><strong>Link</strong> ' || date(created) || ' <a href="'|| link_url || '">'
      || link_title || '</a>:</p><p>' || ' ' || replace(commentary, '
', '<br>') || '</p>'
      as html,
    json_object(
      'created', date(created),
      'link_url', link_url,
      'link_title', link_title,
      'commentary', commentary,
      'use_markdown', use_markdown
    ) as json,
  link_url as external_url
  from blog_blogmark
  union all
  select
    id,
    'quotation' as type,
    source,
    created,
    slug,
    '<strong>quote</strong> ' || date(created) ||
    '<blockquote><p><em>' ||
    replace(quotation, '
', '<br>') ||
    '</em></p></blockquote><p><a href="' ||
    coalesce(source_url, '#') || '">' || source || '</a>' ||
    case
        when nullif(trim(context), '') is not null
        then ', ' || context
        else ''
    end ||
    '</p>' as html,
    'null' as json,
    source_url as external_url
  from blog_quotation
  union all
  select
    id,
    'note' as type,
    case
      when title is not null and title <> '' then title
      else 'Note on ' || date(created)
    end,
    created,
    slug,
    'No HTML',
    json_object(
      'created', date(created),
      'link_url', 'https://simonwillison.net/' || strftime('%Y/', created)
      || substr('JanFebMarAprMayJunJulAugSepOctNovDec', (strftime('%m', created) - 1) * 3 + 1, 3)
      || '/' || cast(strftime('%d', created) as integer) || '/' || slug || '/',
      'link_title', '',
      'commentary', body,
      'use_markdown', 1
    ),
    '' as external_url
  from blog_note
  union all
  select
    rowid,
    'til' as type,
    title,
    created,
    'null' as slug,
    '<p><strong>TIL</strong> ' || date(created) || ' <a href="'|| 'https://til.simonwillison.net/' || topic || '/' || slug || '">' || title || '</a>:' || ' ' || substr(html, 1, instr(html, '</p>') - 1) || ' &#8230;</p>' as html,
    'null' as json,
    'https://til.simonwillison.net/' || topic || '/' || slug as external_url
  from til
),
collected as (
  select
    id,
    type,
    title,
    case
      when type = 'til'
      then external_url
      else 'https://simonwillison.net/' || strftime('%Y/', created)
      || substr('JanFebMarAprMayJunJulAugSepOctNovDec', (strftime('%m', created) - 1) * 3 + 1, 3) ||
      '/' || cast(strftime('%d', created) as integer) || '/' || slug || '/'
      end as url,
    created,
    html,
    json,
    external_url,
    case
      when type = 'entry' then (
        select json_group_array(tag)
        from blog_tag
        join blog_entry_tags on blog_tag.id = blog_entry_tags.tag_id
        where blog_entry_tags.entry_id = content.id
      )
      when type = 'blogmark' then (
        select json_group_array(tag)
        from blog_tag
        join blog_blogmark_tags on blog_tag.id = blog_blogmark_tags.tag_id
        where blog_blogmark_tags.blogmark_id = content.id
      )
      when type = 'quotation' then (
        select json_group_array(tag)
        from blog_tag
        join blog_quotation_tags on blog_tag.id = blog_quotation_tags.tag_id
        where blog_quotation_tags.quotation_id = content.id
      )
      else '[]'
    end as tags
  from content
  where created >= date('now', '-' || :numdays || ' days')
  order by created desc
)
select id, type, title, url, created, html, json, external_url, tags
from collected
order by
  case type
    when 'entry' then 0
    else 1
  end,
  case type
    when 'entry' then created
    else -strftime('%s', created)
  end desc;
`;

      function showStatus(message, type = 'loading') {
        statusEl.textContent = message;
        statusEl.className = 'status ' + type;
      }

      function hideStatus() {
        statusEl.className = 'status hidden';
      }

      // Fetch RSS from GitHub backup or Cloudflare worker
      async function fetchRSS() {
        if (rssInput.value.trim()) {
          return rssInput.value.trim();
        }

        try {
          // Try Cloudflare worker first (more up to date)
          const response = await fetch('https://restless-cherry-7938.simonw.workers.dev/');
          if (response.ok) {
            return await response.text();
          }
        } catch (e) {
          console.log('Cloudflare worker failed, trying GitHub backup');
        }

        // Fallback to GitHub backup
        const response = await fetch('https://raw.githubusercontent.com/simonw/simonwillisonblog-backup/main/simonw-substack-com.xml');
        return await response.text();
      }

      // Parse RSS and extract previous newsletter links
      function parseRSS(rssText) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(rssText, 'application/xml');

        // Get previous newsletter date
        const pubDateEl = doc.querySelector('channel > item > pubDate');
        if (pubDateEl) {
          const date = new Date(pubDateEl.textContent);
          daysSinceLastNewsletter = (new Date() - date) / (1000 * 60 * 60 * 24);
          daysSinceEl.textContent = `${daysSinceLastNewsletter.toFixed(2)} days since the last newsletter.`;

          // Set default numDays to days since last newsletter + 1
          const defaultDays = Math.min(60, Math.ceil(daysSinceLastNewsletter) + 1);
          numDaysInput.value = defaultDays;
          numDaysValue.textContent = defaultDays;
        }

        // Extract HTML content from all items
        const namespaceResolver = (prefix) => {
          const ns = { content: 'http://purl.org/rss/1.0/modules/content/' };
          return ns[prefix] || null;
        };

        const result = doc.evaluate(
          '//content:encoded',
          doc,
          namespaceResolver,
          XPathResult.ANY_TYPE,
          null
        );

        let node;
        let html = [];
        while ((node = result.iterateNext())) {
          html.push(node.textContent);
        }
        const allHtml = html.join('\n');

        // Extract URLs using regex
        const regex = /(?:"|&quot;)(https?:\/\/[^\s"<>]+)(?:"|&quot;)/g;
        previousLinks = Array.from(allHtml.matchAll(regex), match => match[1]);

        renderLinksTable();
      }

      // Fetch content from Datasette
      async function fetchContent(numDays) {
        const url = `https://datasette.simonwillison.net/simonwillisonblog.json?sql=${encodeURIComponent(sql)}&_shape=array&numdays=${numDays}`;
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Failed to fetch content: ${response.status}`);
        }
        return await response.json();
      }

      // Filter content based on settings
      function filterContent() {
        const skipExisting = skipExistingInput.checked;
        const onlyPreCutoff = onlyPreCutoffInput.checked;

        // Filter by existing links
        let filtered = skipExisting
          ? rawContent.filter(e => !previousLinks.includes(e.url) && !previousLinks.includes(e.external_url))
          : rawContent;

        // Parse tags
        filtered = filtered.map(({ tags, ...rest }) => ({
          ...rest,
          tags: typeof tags === 'string' ? JSON.parse(tags) : tags
        }));

        // Apply cutoff and markdown rendering
        if (onlyPreCutoff) {
          filtered = filtered.map(e => {
            if (e.json !== 'null' && (e.type === 'blogmark' || e.type === 'note')) {
              const info = typeof e.json === 'string' ? JSON.parse(e.json) : e.json;
              if (info.use_markdown) {
                const entry = { ...e };
                if (e.type === 'blogmark') {
                  const commentary = marked.parse(info.commentary || '');
                  entry.html = `<p><strong>Link</strong> ${info.created} <a href="${info.link_url}">${info.link_title}</a>:</p>${commentary}`;
                } else if (e.type === 'note') {
                  const commentary = marked.parse(info.commentary || '');
                  entry.html = `<p><strong>Note</strong> <a href="${e.url}">${info.created}</a></p>${commentary}`;
                }
                return entry;
              }
            }

            if (e.type === 'quotation' && e.html) {
              // Process quotation HTML
              const entry = { ...e };
              return entry;
            }

            if (e.html) {
              const entry = { ...e };
              entry.html = entry.html.split('<!-- cutoff -->')[0];
              return entry;
            }
            return e;
          });
        }

        content = filtered;
        entries = content.filter(e => e.type === 'entry');
        blogmarks = content.filter(e => e.type === 'blogmark');
        quotations = content.filter(e => e.type === 'quotation');
        tils = content.filter(e => e.type === 'til');
        notes = content.filter(e => e.type === 'note');

        // Initialize story order
        storyOrder = entries.map(e => `${e.id}: ${e.title}`).reverse();

        renderStoryOrder();
        generateNewsletter();
      }

      // Render story order drag-and-drop list
      function renderStoryOrder() {
        if (entries.length <= 1) {
          storyOrderSection.classList.add('hidden');
          return;
        }
        storyOrderSection.classList.remove('hidden');

        storyOrderList.innerHTML = '';
        storyOrder.forEach(item => {
          const li = document.createElement('li');
          li.textContent = item;
          li.draggable = true;

          li.addEventListener('dragstart', (e) => {
            li.classList.add('dragging');
            e.dataTransfer.setData('text/plain', '');
          });

          li.addEventListener('dragend', () => {
            li.classList.remove('dragging');
            document.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(el => {
              el.classList.remove('drag-over-top', 'drag-over-bottom');
            });
          });

          li.addEventListener('dragover', (e) => {
            e.preventDefault();
            const dragging = document.querySelector('.dragging');
            if (dragging === li) return;

            const rect = li.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;

            li.classList.remove('drag-over-top', 'drag-over-bottom');
            if (e.clientY < midY) {
              li.classList.add('drag-over-top');
            } else {
              li.classList.add('drag-over-bottom');
            }
          });

          li.addEventListener('dragleave', () => {
            li.classList.remove('drag-over-top', 'drag-over-bottom');
          });

          li.addEventListener('drop', (e) => {
            e.preventDefault();
            const dragging = document.querySelector('.dragging');
            if (!dragging || dragging === li) return;

            const rect = li.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;

            if (e.clientY < midY) {
              storyOrderList.insertBefore(dragging, li);
            } else {
              storyOrderList.insertBefore(dragging, li.nextSibling);
            }

            li.classList.remove('drag-over-top', 'drag-over-bottom');

            // Update storyOrder array
            storyOrder = Array.from(storyOrderList.children).map(el => el.textContent);
            generateNewsletter();
          });

          storyOrderList.appendChild(li);
        });
      }

      // Generate newsletter HTML
      function generateNewsletter() {
        const idOrder = storyOrder.map(s => parseInt(s.split(':')[0], 10));

        let html = '';

        // Table of contents
        if (entries.length) {
          const sortedEntries = [...entries].sort((a, b) => {
            const indexA = idOrder.indexOf(a.id);
            const indexB = idOrder.indexOf(b.id);
            return indexA - indexB;
          });

          html += '<p>In this newsletter:</p><ul>';
          html += sortedEntries.map(e => `<li>${e.title}</li>`).join('\n');
          html += '</ul>';
        }

        // Summary of extras
        const extras = [];
        if (blogmarks.length) {
          extras.push(`${blogmarks.length} link${blogmarks.length > 1 ? 's' : ''}`);
        }
        if (quotations.length) {
          extras.push(`${quotations.length} quotation${quotations.length > 1 ? 's' : ''}`);
        }
        if (tils.length) {
          extras.push(`${tils.length} TIL${tils.length > 1 ? 's' : ''}`);
        }
        if (notes.length) {
          extras.push(`${notes.length} note${notes.length > 1 ? 's' : ''}`);
        }
        if (extras.length) {
          html += `<p>Plus ${extras.join(' and ')}</p>`;
        }

        // Sponsor message
        html += `<p><em>If you find this newsletter useful, please consider <a href="https://github.com/sponsors/simonw">sponsoring me via GitHub</a>. $10/month and higher sponsors get a monthly newsletter with my summary of the most important trends of the past 30 days - here are previews from <a href="https://gist.github.com/simonw/43bf3bd7f9951a8e82a9e61b53399ede">August</a> and <a href="https://gist.github.com/simonw/d6d4d86afc0d76767c63f23fc5137030">September</a>.</em></p>`;

        // Content sorted by story order
        const sortedContent = [...content].sort((a, b) => {
          const notFoundIndex = idOrder.length + 1;
          const indexA = idOrder.indexOf(a.id) !== -1 ? idOrder.indexOf(a.id) : notFoundIndex;
          const indexB = idOrder.indexOf(b.id) !== -1 ? idOrder.indexOf(b.id) : notFoundIndex;
          return indexA - indexB;
        });

        html += sortedContent.map(c => c.html + '<hr>').join('\n');

        newsletterHTML = html;
        htmlLengthEl.textContent = `Length of HTML: ${newsletterHTML.length.toLocaleString()} characters`;
        previewEl.innerHTML = html;
      }

      // Copy rich text to clipboard
      function copyRichText(htmlContent) {
        const tempElement = document.createElement('div');
        tempElement.innerHTML = htmlContent;
        document.body.appendChild(tempElement);

        const range = document.createRange();
        range.selectNode(tempElement);

        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        document.execCommand('copy');

        selection.removeAllRanges();
        document.body.removeChild(tempElement);

        showStatus('Copied to clipboard!', 'success');
        setTimeout(hideStatus, 2000);
      }

      // Render links table
      function renderLinksTable() {
        const searchTerm = linksSearch.value.toLowerCase();
        const filtered = previousLinks.filter(url => url.toLowerCase().includes(searchTerm));

        let html = '<table>';
        filtered.slice(0, 100).forEach(url => {
          html += `<tr><td><a href="${url}" target="_blank">${url}</a></td></tr>`;
        });
        if (filtered.length > 100) {
          html += `<tr><td>...and ${filtered.length - 100} more</td></tr>`;
        }
        html += '</table>';
        linksTable.innerHTML = html;
      }

      // Event listeners
      numDaysInput.addEventListener('input', () => {
        numDaysValue.textContent = numDaysInput.value;
      });

      numDaysInput.addEventListener('change', async () => {
        showStatus('Fetching content...');
        try {
          rawContent = await fetchContent(numDaysInput.value);
          filterContent();
          hideStatus();
        } catch (e) {
          showStatus('Error: ' + e.message, 'error');
        }
      });

      skipExistingInput.addEventListener('change', filterContent);
      onlyPreCutoffInput.addEventListener('change', filterContent);

      rssInput.addEventListener('change', async () => {
        if (rssInput.value.trim()) {
          parseRSS(rssInput.value.trim());
          filterContent();
        }
      });

      document.getElementById('copyRichText').addEventListener('click', () => {
        copyRichText(newsletterHTML);
      });

      document.getElementById('copyLinksOnly').addEventListener('click', () => {
        const linksOnlyHtml = content
          .filter(e => e.type !== 'entry')
          .map(e => e.html)
          .join('\n\n');
        copyRichText(linksOnlyHtml);
      });

      linksSearch.addEventListener('input', renderLinksTable);

      // Initialize
      async function init() {
        showStatus('Loading...');
        try {
          // Fetch RSS first to get previous links and days since
          const rss = await fetchRSS();
          parseRSS(rss);

          // Fetch content
          rawContent = await fetchContent(numDaysInput.value);
          filterContent();

          hideStatus();
        } catch (e) {
          console.error(e);
          showStatus('Error: ' + e.message, 'error');
        }
      }

      init();
    })();
  </script>
</body>
</html>
