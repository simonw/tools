<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blog to Newsletter</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
    }
    h1 {
      margin-top: 0;
      color: #1a1a1a;
    }
    .info {
      background: #f0f7ff;
      border: 1px solid #b8d4ff;
      border-radius: 6px;
      padding: 15px;
      margin-bottom: 20px;
    }
    .info a {
      color: #0066cc;
    }
    .days-since {
      font-size: 1.1em;
      color: #666;
      margin-bottom: 15px;
    }
    .controls {
      background: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .control-group {
      margin-bottom: 15px;
    }
    .control-group:last-child {
      margin-bottom: 0;
    }
    label {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
    }
    input[type="range"] {
      width: 200px;
    }
    input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
    textarea {
      width: 100%;
      height: 100px;
      padding: 10px;
      font-family: inherit;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
    }
    .buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    button {
      padding: 12px 20px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .primary-btn {
      background: #0066cc;
      color: white;
      font-weight: bold;
    }
    .primary-btn:hover {
      background: #0055aa;
    }
    .secondary-btn {
      background: #666;
      color: white;
    }
    .secondary-btn:hover {
      background: #555;
    }
    .html-length {
      color: #666;
      font-size: 0.9em;
      margin-bottom: 10px;
    }
    .status {
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 15px;
    }
    .status.loading {
      background: #fff3cd;
      color: #856404;
    }
    .status.error {
      background: #f8d7da;
      color: #721c24;
    }
    .status.success {
      background: #d4edda;
      color: #155724;
    }
    h2 {
      margin-top: 30px;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }
    h3 {
      margin-top: 20px;
    }
    .story-order {
      margin-bottom: 20px;
    }
    .story-order ul {
      list-style: none;
      padding: 0;
      margin: 10px 0;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      user-select: none;
      -webkit-user-select: none;
    }
    .story-order li {
      padding: 12px 15px;
      padding-left: 40px;
      border-bottom: 1px solid #eee;
      cursor: grab;
      background: white;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background-color 0.15s ease;
      position: relative;
      touch-action: none;
    }
    .story-order li::before {
      content: '⋮⋮';
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: #aaa;
      font-size: 14px;
      letter-spacing: 2px;
    }
    .story-order li:last-child {
      border-bottom: none;
    }
    .story-order li:hover {
      background: #f8f8f8;
    }
    .story-order li:active {
      cursor: grabbing;
    }
    .story-order li.dragging {
      background: #e8f4ff;
      box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
      transform: scale(1.02);
      z-index: 100;
      border-radius: 4px;
    }
    .story-order li.drag-over {
      background: #f0f7ff;
    }
    .story-order .drop-indicator {
      height: 3px;
      background: #0066cc;
      border-radius: 2px;
      margin: -1.5px 0;
      pointer-events: none;
    }
    .newsletter-preview {
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 20px;
      margin-top: 20px;
    }
    .newsletter-preview img {
      max-width: 100%;
      height: auto;
    }
    .newsletter-preview hr {
      border: none;
      border-top: 1px solid #ddd;
      margin: 20px 0;
    }
    .newsletter-preview h3 a {
      color: #0066cc;
      text-decoration: none;
    }
    .newsletter-preview h3 a:hover {
      text-decoration: underline;
    }
    .newsletter-preview blockquote {
      border-left: 4px solid #ddd;
      margin: 10px 0;
      padding: 10px 20px;
      background: #f9f9f9;
    }
    .previous-links {
      margin-top: 30px;
    }
    .previous-links input[type="text"] {
      width: 100%;
      padding: 10px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    .links-table {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .links-table table {
      width: 100%;
      border-collapse: collapse;
    }
    .links-table td {
      padding: 8px 12px;
      border-bottom: 1px solid #eee;
      font-size: 13px;
      word-break: break-all;
    }
    .links-table tr:last-child td {
      border-bottom: none;
    }
    .hidden {
      display: none;
    }
    .long-urls-warning {
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 6px;
      padding: 15px;
      margin-bottom: 20px;
    }
    .long-urls-warning h4 {
      margin: 0 0 10px 0;
      color: #856404;
    }
    .long-urls-warning ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .long-urls-warning li {
      margin-bottom: 10px;
      padding: 10px;
      background: #fffef5;
      border: 1px solid #ffe69c;
      border-radius: 4px;
    }
    .long-urls-warning .url-text {
      font-family: monospace;
      font-size: 12px;
      word-break: break-all;
      color: #666;
      margin-bottom: 8px;
    }
    .long-urls-warning .url-length {
      font-size: 11px;
      color: #856404;
      margin-bottom: 8px;
    }
    .long-urls-warning .edit-url-btn {
      padding: 6px 12px;
      font-size: 13px;
      background: #ffc107;
      color: #000;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .long-urls-warning .edit-url-btn:hover {
      background: #e0a800;
    }
    .newsletter-item {
      position: relative;
    }
    .newsletter-item .delete-item-btn {
      position: absolute;
      top: 0;
      right: 0;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      font-size: 16px;
      line-height: 22px;
      text-align: center;
      cursor: pointer;
      opacity: 0.5;
      transition: opacity 0.15s;
    }
    .newsletter-item .delete-item-btn:hover {
      opacity: 1;
    }
  </style>
</head>
<body>
  <h1>Blog to Newsletter</h1>

  <div class="info">
    <p>This tool generates HTML from the <a href="https://datasette.simonwillison.net/simonwillisonblog" target="_blank">Datasette backup of simonwillison.net</a> (<a href="https://github.com/simonw/simonwillisonblog-backup/actions/workflows/backup.yml">action</a>) for copying into Substack.</p>
    <p>See: <a href="https://simonwillison.net/2023/Apr/4/substack-observable/" target="_blank">Semi-automating a Substack newsletter with an Observable notebook</a></p>
  </div>

  <div class="days-since" id="daysSince">Loading...</div>

  <div class="controls">
    <div class="control-group">
      <label>
        Last <span id="numDaysValue">7</span> days:
        <input type="range" id="numDays" min="1" max="60" value="7">
      </label>
    </div>
    <div class="control-group">
      <label>
        <input type="checkbox" id="skipExisting" checked>
        Skip content sent in prior newsletters
      </label>
    </div>
    <div class="control-group">
      <label>
        <input type="checkbox" id="onlyPreCutoff" checked>
        Only include post content prior to the cutoff comment
      </label>
    </div>
    <div class="control-group">
      <label for="rssInput">Paste RSS here if Substack feed is unavailable:</label>
      <textarea id="rssInput" placeholder="Paste RSS XML content here (optional)"></textarea>
    </div>
  </div>

  <div id="status" class="status hidden"></div>

  <div class="buttons">
    <button class="primary-btn" id="copyRichText">Copy rich text newsletter to clipboard</button>
    <button class="primary-btn" id="copyHtml">Copy HTML newsletter to clipboard</button>
    <button class="secondary-btn" id="copyLinksOnly">Copy just the links/quotes/TILs</button>
  </div>

  <div class="html-length" id="htmlLength"></div>

  <div class="long-urls-warning hidden" id="longUrlsWarning">
    <h4>Warning: Long URLs detected (>200 characters)</h4>
    <ul id="longUrlsList"></ul>
  </div>

  <div class="story-order" id="storyOrderSection">
    <h3>Set order of the stories:</h3>
    <ul id="storyOrderList"></ul>
  </div>

  <h2>Newsletter preview</h2>
  <div class="newsletter-preview" id="preview"></div>

  <div class="previous-links">
    <h2>Links sent in previous newsletters</h2>
    <input type="text" id="linksSearch" placeholder="Search previous links...">
    <div class="links-table" id="linksTable"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    (async function() {
      // State
      let rawContent = [];
      let content = [];
      let entries = [];
      let blogmarks = [];
      let quotations = [];
      let tils = [];
      let notes = [];
      let previousLinks = [];
      let storyOrder = [];
      let newsletterHTML = '';
      let daysSinceLastNewsletter = 0;

      // DOM elements
      const numDaysInput = document.getElementById('numDays');
      const numDaysValue = document.getElementById('numDaysValue');
      const skipExistingInput = document.getElementById('skipExisting');
      const onlyPreCutoffInput = document.getElementById('onlyPreCutoff');
      const rssInput = document.getElementById('rssInput');
      const statusEl = document.getElementById('status');
      const previewEl = document.getElementById('preview');
      const htmlLengthEl = document.getElementById('htmlLength');
      const storyOrderList = document.getElementById('storyOrderList');
      const storyOrderSection = document.getElementById('storyOrderSection');
      const linksSearch = document.getElementById('linksSearch');
      const linksTable = document.getElementById('linksTable');
      const daysSinceEl = document.getElementById('daysSince');
      const longUrlsWarning = document.getElementById('longUrlsWarning');
      const longUrlsList = document.getElementById('longUrlsList');

      // URL replacements map (old URL -> new URL)
      let urlReplacements = new Map();

      // Persist story order in URL hash fragment
      function updateUrlHash() {
        const ids = storyOrder.map(s => parseInt(s.split(':')[0], 10));
        history.replaceState(null, '', '#order=' + ids.join(','));
      }

      // Read story order from URL hash and reorder storyOrder accordingly
      function applyOrderFromHash() {
        const hash = location.hash;
        if (!hash.startsWith('#order=')) return;

        const hashIds = hash.slice('#order='.length).split(',')
          .map(s => parseInt(s, 10))
          .filter(id => !isNaN(id));

        if (hashIds.length === 0) return;

        const storyMap = new Map(
          storyOrder.map(s => [parseInt(s.split(':')[0], 10), s])
        );
        const currentIds = Array.from(storyMap.keys());

        // Keep only IDs that exist in current entries
        const validHashIds = hashIds.filter(id => storyMap.has(id));
        // Remaining IDs not mentioned in the hash, in their default order
        const remainingIds = currentIds.filter(id => !validHashIds.includes(id));

        const newIdOrder = [...validHashIds, ...remainingIds];
        storyOrder = newIdOrder.map(id => storyMap.get(id));
      }

      // SQL query
      const sql = `
with content as (
  select
    id,
    'entry' as type,
    title,
    created,
    slug,
    '<h3><a href="' || 'https://simonwillison.net/' || strftime('%Y/', created)
      || substr('JanFebMarAprMayJunJulAugSepOctNovDec', (strftime('%m', created) - 1) * 3 + 1, 3)
      || '/' || cast(strftime('%d', created) as integer) || '/' || slug || '/' || '">'
      || title || '</a> - ' || date(created) || '</h3>' || body
      as html,
    'null' as json,
    '' as external_url
  from blog_entry
  union all
  select
    id,
    'blogmark' as type,
    link_title,
    created,
    slug,
    '<p><strong>Link</strong> ' || date(created) || ' <a href="'|| link_url || '">'
      || link_title || '</a>:</p><p>' || ' ' || replace(commentary, '
', '<br>') || '</p>'
      as html,
    json_object(
      'created', date(created),
      'link_url', link_url,
      'link_title', link_title,
      'commentary', commentary,
      'use_markdown', use_markdown
    ) as json,
  link_url as external_url
  from blog_blogmark
  union all
  select
    id,
    'quotation' as type,
    source,
    created,
    slug,
    '<strong>Quote</strong> ' || date(created) ||
    '<blockquote><p><em>' ||
    replace(quotation, '
', '<br>') ||
    '</em></p></blockquote><p><a href="' ||
    coalesce(source_url, '#') || '">' || source || '</a>' ||
    case
        when nullif(trim(context), '') is not null
        then ', ' || context
        else ''
    end ||
    '</p>' as html,
    json_object(
      'created', date(created),
      'quotation', quotation,
      'source', source,
      'source_url', source_url,
      'context', context
    ) as json,
    source_url as external_url
  from blog_quotation
  union all
  select
    id,
    'note' as type,
    case
      when title is not null and title <> '' then title
      else 'Note on ' || date(created)
    end,
    created,
    slug,
    'No HTML',
    json_object(
      'created', date(created),
      'link_url', 'https://simonwillison.net/' || strftime('%Y/', created)
      || substr('JanFebMarAprMayJunJulAugSepOctNovDec', (strftime('%m', created) - 1) * 3 + 1, 3)
      || '/' || cast(strftime('%d', created) as integer) || '/' || slug || '/',
      'link_title', '',
      'commentary', body,
      'use_markdown', 1
    ),
    '' as external_url
  from blog_note
  union all
  select
    rowid,
    'til' as type,
    title,
    created,
    'null' as slug,
    '<p><strong>TIL</strong> ' || date(created) || ' <a href="'|| 'https://til.simonwillison.net/' || topic || '/' || slug || '">' || title || '</a>:' || ' ' || substr(html, 1, instr(html, '</p>') - 1) || ' &#8230;</p>' as html,
    'null' as json,
    'https://til.simonwillison.net/' || topic || '/' || slug as external_url
  from til
),
collected as (
  select
    id,
    type,
    title,
    case
      when type = 'til'
      then external_url
      else 'https://simonwillison.net/' || strftime('%Y/', created)
      || substr('JanFebMarAprMayJunJulAugSepOctNovDec', (strftime('%m', created) - 1) * 3 + 1, 3) ||
      '/' || cast(strftime('%d', created) as integer) || '/' || slug || '/'
      end as url,
    created,
    html,
    json,
    external_url,
    case
      when type = 'entry' then (
        select json_group_array(tag)
        from blog_tag
        join blog_entry_tags on blog_tag.id = blog_entry_tags.tag_id
        where blog_entry_tags.entry_id = content.id
      )
      when type = 'blogmark' then (
        select json_group_array(tag)
        from blog_tag
        join blog_blogmark_tags on blog_tag.id = blog_blogmark_tags.tag_id
        where blog_blogmark_tags.blogmark_id = content.id
      )
      when type = 'quotation' then (
        select json_group_array(tag)
        from blog_tag
        join blog_quotation_tags on blog_tag.id = blog_quotation_tags.tag_id
        where blog_quotation_tags.quotation_id = content.id
      )
      else '[]'
    end as tags
  from content
  where created >= date('now', '-' || :numdays || ' days')
  order by created desc
)
select id, type, title, url, created, html, json, external_url, tags
from collected
order by
  case type
    when 'entry' then 0
    else 1
  end,
  case type
    when 'entry' then created
    else -strftime('%s', created)
  end desc;
`;

      function showStatus(message, type = 'loading') {
        statusEl.textContent = message;
        statusEl.className = 'status ' + type;
      }

      function hideStatus() {
        statusEl.className = 'status hidden';
      }

      // Fetch RSS from GitHub backup or Cloudflare worker
      async function fetchRSS() {
        if (rssInput.value.trim()) {
          return rssInput.value.trim();
        }

        try {
          // Try Cloudflare worker first (more up to date)
          const response = await fetch('https://restless-cherry-7938.simonw.workers.dev/');
          if (response.ok) {
            return await response.text();
          }
        } catch (e) {
          console.log('Cloudflare worker failed, trying GitHub backup');
        }

        // Fallback to GitHub backup
        const response = await fetch('https://raw.githubusercontent.com/simonw/simonwillisonblog-backup/main/simonw-substack-com.xml');
        return await response.text();
      }

      // Parse RSS and extract previous newsletter links
      function parseRSS(rssText) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(rssText, 'application/xml');

        // Get previous newsletter date
        const pubDateEl = doc.querySelector('channel > item > pubDate');
        if (pubDateEl) {
          const date = new Date(pubDateEl.textContent);
          daysSinceLastNewsletter = (new Date() - date) / (1000 * 60 * 60 * 24);
          daysSinceEl.textContent = `${daysSinceLastNewsletter.toFixed(2)} days since the last newsletter.`;

          // Set default numDays to days since last newsletter + 1
          const defaultDays = Math.min(60, Math.ceil(daysSinceLastNewsletter) + 1);
          numDaysInput.value = defaultDays;
          numDaysValue.textContent = defaultDays;
        }

        // Extract HTML content from all items
        const namespaceResolver = (prefix) => {
          const ns = { content: 'http://purl.org/rss/1.0/modules/content/' };
          return ns[prefix] || null;
        };

        const result = doc.evaluate(
          '//content:encoded',
          doc,
          namespaceResolver,
          XPathResult.ANY_TYPE,
          null
        );

        let node;
        let html = [];
        while ((node = result.iterateNext())) {
          html.push(node.textContent);
        }
        const allHtml = html.join('\n');

        // Extract URLs using regex
        const regex = /(?:"|&quot;)(https?:\/\/[^\s"<>]+)(?:"|&quot;)/g;
        previousLinks = Array.from(allHtml.matchAll(regex), match => match[1]);

        renderLinksTable();
      }

      // Fetch content from Datasette
      async function fetchContent(numDays) {
        const url = `https://datasette.simonwillison.net/simonwillisonblog.json?sql=${encodeURIComponent(sql)}&_shape=array&numdays=${numDays}`;
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Failed to fetch content: ${response.status}`);
        }
        return await response.json();
      }

      // Filter content based on settings
      function filterContent() {
        const skipExisting = skipExistingInput.checked;
        const onlyPreCutoff = onlyPreCutoffInput.checked;

        // Filter by existing links
        let filtered = skipExisting
          ? rawContent.filter(e => !previousLinks.includes(e.url) && !previousLinks.includes(e.external_url))
          : rawContent;

        // Parse tags
        filtered = filtered.map(({ tags, ...rest }) => ({
          ...rest,
          tags: typeof tags === 'string' ? JSON.parse(tags) : tags
        }));

        // Apply cutoff and markdown rendering
        if (onlyPreCutoff) {
          filtered = filtered.map(e => {
            if (e.json !== 'null' && (e.type === 'blogmark' || e.type === 'note')) {
              const info = typeof e.json === 'string' ? JSON.parse(e.json) : e.json;
              if (info.use_markdown) {
                const entry = { ...e };
                if (e.type === 'blogmark') {
                  const commentary = marked.parse(info.commentary || '');
                  entry.html = `<p><strong>Link</strong> ${info.created} <a href="${info.link_url}">${info.link_title}</a>:</p>${commentary}`;
                } else if (e.type === 'note') {
                  const commentary = marked.parse(info.commentary || '');
                  entry.html = `<p><strong>Note</strong> <a href="${e.url}">${info.created}</a></p>${commentary}`;
                }
                return entry;
              }
            }

            if (e.type === 'quotation' && e.json !== 'null') {
              const info = typeof e.json === 'string' ? JSON.parse(e.json) : e.json;
              const entry = { ...e };
              const quotationHtml = marked.parse(info.quotation || '');
              const contextHtml = info.context ? ', ' + marked.parseInline(info.context) : '';
              entry.html = `<p><strong>Quote</strong> ${info.created}</p><blockquote>${quotationHtml}</blockquote><p><a href="${info.source_url || '#'}">${info.source}</a>${contextHtml}</p>`;
              return entry;
            }

            if (e.html) {
              const entry = { ...e };
              entry.html = entry.html.split('<!-- cutoff -->')[0];
              return entry;
            }
            return e;
          });
        }

        content = filtered;
        entries = content.filter(e => e.type === 'entry');
        blogmarks = content.filter(e => e.type === 'blogmark');
        quotations = content.filter(e => e.type === 'quotation');
        tils = content.filter(e => e.type === 'til');
        notes = content.filter(e => e.type === 'note');

        // Initialize story order
        storyOrder = entries.map(e => `${e.id}: ${e.title}`).reverse();
        applyOrderFromHash();

        renderStoryOrder();
        generateNewsletter();
      }

      // Render story order drag-and-drop list with touch support
      function renderStoryOrder() {
        if (entries.length <= 1) {
          storyOrderSection.classList.add('hidden');
          return;
        }
        storyOrderSection.classList.remove('hidden');

        storyOrderList.innerHTML = '';

        let draggedItem = null;
        let dropIndicator = null;
        let touchStartY = 0;
        let initialIndex = 0;

        // Create drop indicator element
        function createDropIndicator() {
          const indicator = document.createElement('div');
          indicator.className = 'drop-indicator';
          return indicator;
        }

        // Remove any existing drop indicator
        function removeDropIndicator() {
          if (dropIndicator && dropIndicator.parentNode) {
            dropIndicator.parentNode.removeChild(dropIndicator);
          }
          dropIndicator = null;
        }

        // Get insertion point based on Y position
        function getInsertionPoint(y) {
          const items = Array.from(storyOrderList.querySelectorAll('li:not(.dragging)'));

          for (const item of items) {
            const rect = item.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;

            if (y < midY) {
              return { element: item, position: 'before' };
            }
          }

          // If we're past all items, insert after the last one
          if (items.length > 0) {
            return { element: items[items.length - 1], position: 'after' };
          }

          return null;
        }

        // Update drop indicator position
        function updateDropIndicator(y) {
          const insertion = getInsertionPoint(y);

          if (!insertion) {
            removeDropIndicator();
            return;
          }

          if (!dropIndicator) {
            dropIndicator = createDropIndicator();
          }

          if (insertion.position === 'before') {
            insertion.element.parentNode.insertBefore(dropIndicator, insertion.element);
          } else {
            insertion.element.parentNode.insertBefore(dropIndicator, insertion.element.nextSibling);
          }
        }

        // Finalize the drop
        function finalizeDrop(y) {
          if (!draggedItem) return;

          const insertion = getInsertionPoint(y);

          if (insertion) {
            if (insertion.position === 'before') {
              storyOrderList.insertBefore(draggedItem, insertion.element);
            } else {
              storyOrderList.insertBefore(draggedItem, insertion.element.nextSibling);
            }
          }

          draggedItem.classList.remove('dragging');
          removeDropIndicator();

          // Update storyOrder array
          storyOrder = Array.from(storyOrderList.querySelectorAll('li')).map(el => el.textContent);
          updateUrlHash();
          generateNewsletter();

          draggedItem = null;
        }

        // Create list items
        storyOrder.forEach((item, index) => {
          const li = document.createElement('li');
          li.textContent = item;
          li.draggable = true;

          // Mouse drag events
          li.addEventListener('dragstart', (e) => {
            draggedItem = li;
            initialIndex = index;
            li.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', '');

            // Delay to allow the drag image to be captured
            requestAnimationFrame(() => {
              li.style.opacity = '0.5';
            });
          });

          li.addEventListener('dragend', (e) => {
            li.style.opacity = '';
            finalizeDrop(e.clientY);
          });

          li.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            updateDropIndicator(e.clientY);
          });

          li.addEventListener('drop', (e) => {
            e.preventDefault();
          });

          // Touch events for mobile support
          li.addEventListener('touchstart', (e) => {
            if (e.touches.length !== 1) return;

            draggedItem = li;
            initialIndex = index;
            touchStartY = e.touches[0].clientY;

            // Small delay to distinguish from scroll
            setTimeout(() => {
              if (draggedItem === li) {
                li.classList.add('dragging');
              }
            }, 100);
          }, { passive: true });

          li.addEventListener('touchmove', (e) => {
            if (!draggedItem || draggedItem !== li) return;

            e.preventDefault();

            const touch = e.touches[0];
            const y = touch.clientY;

            if (!li.classList.contains('dragging')) {
              li.classList.add('dragging');
            }

            updateDropIndicator(y);
          }, { passive: false });

          li.addEventListener('touchend', (e) => {
            if (!draggedItem || draggedItem !== li) return;

            const touch = e.changedTouches[0];
            finalizeDrop(touch.clientY);
          });

          li.addEventListener('touchcancel', () => {
            if (draggedItem) {
              draggedItem.classList.remove('dragging');
              removeDropIndicator();
              draggedItem = null;
            }
          });

          storyOrderList.appendChild(li);
        });

        // Handle dragover on the list itself for edge cases
        storyOrderList.addEventListener('dragover', (e) => {
          e.preventDefault();
          updateDropIndicator(e.clientY);
        });

        storyOrderList.addEventListener('dragleave', (e) => {
          // Only remove if leaving the list entirely
          if (!storyOrderList.contains(e.relatedTarget)) {
            removeDropIndicator();
          }
        });
      }

      // Generate newsletter HTML
      function generateNewsletter() {
        const idOrder = storyOrder.map(s => parseInt(s.split(':')[0], 10));

        let headerHtml = '';

        // Table of contents
        if (entries.length) {
          const sortedEntries = [...entries].sort((a, b) => {
            const indexA = idOrder.indexOf(a.id);
            const indexB = idOrder.indexOf(b.id);
            return indexA - indexB;
          });

          headerHtml += '<p>In this newsletter:</p><ul>';
          headerHtml += sortedEntries.map(e => `<li>${e.title}</li>`).join('\n');
          headerHtml += '</ul>';
        }

        // Summary of extras
        const extras = [];
        if (blogmarks.length) {
          extras.push(`${blogmarks.length} link${blogmarks.length > 1 ? 's' : ''}`);
        }
        if (quotations.length) {
          extras.push(`${quotations.length} quotation${quotations.length > 1 ? 's' : ''}`);
        }
        if (tils.length) {
          extras.push(`${tils.length} TIL${tils.length > 1 ? 's' : ''}`);
        }
        if (notes.length) {
          extras.push(`${notes.length} note${notes.length > 1 ? 's' : ''}`);
        }
        if (extras.length) {
          headerHtml += `<p>Plus ${extras.join(' and ')}</p>`;
        }

        // Sponsor message
        headerHtml += `<p><em>If you find this newsletter useful, please consider <a href="https://github.com/sponsors/simonw">sponsoring me via GitHub</a>. $10/month and higher sponsors get a monthly newsletter with my summary of the most important trends of the past 30 days - here are previews from <a href="https://gist.github.com/simonw/3385bc8c83a8157557f06865a0302753">October</a> and <a href="https://gist.github.com/simonw/fc34b780a9ae19b6be5d732078a572c8">November</a>.</em></p>`;

        // Content sorted by story order
        const sortedContent = [...content].sort((a, b) => {
          const notFoundIndex = idOrder.length + 1;
          const indexA = idOrder.indexOf(a.id) !== -1 ? idOrder.indexOf(a.id) : notFoundIndex;
          const indexB = idOrder.indexOf(b.id) !== -1 ? idOrder.indexOf(b.id) : notFoundIndex;
          return indexA - indexB;
        });

        // Apply URL replacements helper
        function applyReplacements(html) {
          for (const [oldUrl, newUrl] of urlReplacements) {
            html = html.split(oldUrl).join(newUrl);
          }
          return html;
        }

        // Clean newsletter HTML (for copying)
        let html = headerHtml + sortedContent.map(c => c.html + '<hr>').join('\n');
        newsletterHTML = applyReplacements(html);
        htmlLengthEl.textContent = `Length of HTML: ${newsletterHTML.length.toLocaleString()} characters`;

        // Preview HTML with delete buttons for non-entry items
        const previewContentHtml = sortedContent.map(c => {
          const itemHtml = applyReplacements(c.html);
          if (c.type !== 'entry') {
            return `<div class="newsletter-item" data-type="${c.type}" data-id="${c.id}"><button class="delete-item-btn" title="Remove this item">&times;</button>${itemHtml}</div><hr>`;
          }
          return itemHtml + '<hr>';
        }).join('\n');
        previewEl.innerHTML = applyReplacements(headerHtml) + previewContentHtml;

        // Check for long URLs and display warnings
        checkLongUrls(newsletterHTML);
      }

      // Remove an item from the newsletter
      function removeItem(type, id) {
        content = content.filter(e => !(e.type === type && String(e.id) === String(id)));
        blogmarks = blogmarks.filter(e => !(type === 'blogmark' && String(e.id) === String(id)));
        quotations = quotations.filter(e => !(type === 'quotation' && String(e.id) === String(id)));
        tils = tils.filter(e => !(type === 'til' && String(e.id) === String(id)));
        notes = notes.filter(e => !(type === 'note' && String(e.id) === String(id)));
        generateNewsletter();
      }

      // Event delegation for delete buttons in preview
      previewEl.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-item-btn')) {
          const wrapper = e.target.closest('.newsletter-item');
          if (wrapper) {
            removeItem(wrapper.dataset.type, wrapper.dataset.id);
          }
        }
      });

      // Check for URLs longer than 200 characters
      function checkLongUrls(html) {
        const urlRegex = /href="(https?:\/\/[^"]+)"/g;
        const longUrls = new Set();
        let match;

        while ((match = urlRegex.exec(html)) !== null) {
          const url = match[1];
          if (url.length > 200) {
            longUrls.add(url);
          }
        }

        if (longUrls.size === 0) {
          longUrlsWarning.classList.add('hidden');
          return;
        }

        longUrlsWarning.classList.remove('hidden');
        longUrlsList.innerHTML = '';

        for (const url of longUrls) {
          const li = document.createElement('li');

          const urlText = document.createElement('div');
          urlText.className = 'url-text';
          urlText.textContent = url;
          li.appendChild(urlText);

          const urlLength = document.createElement('div');
          urlLength.className = 'url-length';
          urlLength.textContent = `${url.length} characters`;
          li.appendChild(urlLength);

          const editBtn = document.createElement('button');
          editBtn.className = 'edit-url-btn';
          editBtn.textContent = 'Edit URL';
          editBtn.addEventListener('click', () => {
            const newUrl = prompt('Edit this URL:', url);
            if (newUrl !== null && newUrl !== url) {
              urlReplacements.set(url, newUrl);
              generateNewsletter();
            }
          });
          li.appendChild(editBtn);

          longUrlsList.appendChild(li);
        }
      }

      // Copy rich text to clipboard
      function copyRichText(htmlContent) {
        const tempElement = document.createElement('div');
        tempElement.innerHTML = htmlContent;
        document.body.appendChild(tempElement);

        const range = document.createRange();
        range.selectNode(tempElement);

        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        document.execCommand('copy');

        selection.removeAllRanges();
        document.body.removeChild(tempElement);

        showStatus('Copied to clipboard!', 'success');
        setTimeout(hideStatus, 2000);
      }

      // Render links table
      function renderLinksTable() {
        const searchTerm = linksSearch.value.toLowerCase();
        const filtered = previousLinks.filter(url => url.toLowerCase().includes(searchTerm));

        let html = '<table>';
        filtered.slice(0, 100).forEach(url => {
          html += `<tr><td><a href="${url}" target="_blank">${url}</a></td></tr>`;
        });
        if (filtered.length > 100) {
          html += `<tr><td>...and ${filtered.length - 100} more</td></tr>`;
        }
        html += '</table>';
        linksTable.innerHTML = html;
      }

      // Event listeners
      numDaysInput.addEventListener('input', () => {
        numDaysValue.textContent = numDaysInput.value;
      });

      numDaysInput.addEventListener('change', async () => {
        showStatus('Fetching content...');
        try {
          rawContent = await fetchContent(numDaysInput.value);
          filterContent();
          hideStatus();
        } catch (e) {
          showStatus('Error: ' + e.message, 'error');
        }
      });

      skipExistingInput.addEventListener('change', filterContent);
      onlyPreCutoffInput.addEventListener('change', filterContent);

      rssInput.addEventListener('change', async () => {
        if (rssInput.value.trim()) {
          parseRSS(rssInput.value.trim());
          filterContent();
        }
      });

      document.getElementById('copyRichText').addEventListener('click', () => {
        copyRichText(newsletterHTML);
      });

      document.getElementById('copyHtml').addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(newsletterHTML);
          showStatus('HTML copied to clipboard!', 'success');
          setTimeout(hideStatus, 2000);
        } catch (e) {
          showStatus('Failed to copy: ' + e.message, 'error');
        }
      });

      document.getElementById('copyLinksOnly').addEventListener('click', () => {
        const linksOnlyHtml = content
          .filter(e => e.type !== 'entry')
          .map(e => e.html)
          .join('\n\n');
        copyRichText(linksOnlyHtml);
      });

      linksSearch.addEventListener('input', renderLinksTable);

      // Initialize
      async function init() {
        showStatus('Loading...');
        try {
          // Fetch RSS first to get previous links and days since
          const rss = await fetchRSS();
          parseRSS(rss);

          // Fetch content
          rawContent = await fetchContent(numDaysInput.value);
          filterContent();

          hideStatus();
        } catch (e) {
          console.error(e);
          showStatus('Error: ' + e.message, 'error');
        }
      }

      init();
    })();
  </script>
</body>
</html>
