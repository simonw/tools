<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CORS Fetch Tester</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f4f4f5;
      color: #111827;
    }

    .page {
      max-width: 960px;
      margin: 0 auto;
      padding: 24px 16px 40px;
    }

    h1 {
      font-size: 1.6rem;
      margin: 0 0 4px;
    }

    .subtitle {
      font-size: 0.95rem;
      color: #6b7280;
      margin-bottom: 20px;
    }

    .card {
      background: #ffffff;
      border-radius: 12px;
      padding: 16px 18px 18px;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.08);
      margin-bottom: 16px;
    }

    label {
      font-size: 0.9rem;
      font-weight: 600;
      color: #374151;
      display: block;
      margin-bottom: 4px;
    }

    .input-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .method-url-row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    /* Mobile-friendly: 16px minimum font-size prevents iOS zoom */
    input[type="text"],
    textarea,
    select {
      font-size: 16px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      outline: none;
      min-width: 0;
      font-family: inherit;
    }

    input[type="text"]:focus,
    textarea:focus,
    select:focus {
      border-color: #2563eb;
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.25);
    }

    select {
      padding: 8px 10px;
      height: 44px;
      background: #fff;
      cursor: pointer;
      -webkit-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23374151' d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
      padding-right: 30px;
    }

    #method-select {
      width: 110px;
      flex-shrink: 0;
      font-weight: 600;
    }

    #url-input {
      flex: 1;
      display: block;
      padding: 8px 12px;
      height: 44px;
      line-height: 1.3;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 10px 20px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      background: #2563eb;
      color: #ffffff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      white-space: nowrap;
      min-height: 44px;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    button.secondary {
      background: #e5e7eb;
      color: #374151;
    }

    button.secondary:hover:not(:disabled) {
      background: #d1d5db;
    }

    button.danger {
      background: #fee2e2;
      color: #b91c1c;
    }

    button.danger:hover:not(:disabled) {
      background: #fecaca;
    }

    button.accent {
      background: #7c3aed;
      color: #fff;
    }

    button.accent:hover:not(:disabled) {
      background: #6d28d9;
    }

    button span.spinner {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 2px solid rgba(255, 255, 255, 0.6);
      border-top-color: transparent;
      animation: spin 0.7s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .hint {
      font-size: 0.85rem;
      color: #6b7280;
      margin-top: 4px;
    }

    .status-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 6px;
      font-size: 0.9rem;
    }

    .pill {
      border-radius: 999px;
      padding: 4px 12px;
      background: #f3f4f6;
      color: #374151;
    }

    .pill.status-ok {
      background: #dcfce7;
      color: #166534;
    }

    .pill.status-error {
      background: #fee2e2;
      color: #b91c1c;
    }

    .section-title {
      font-size: 0.95rem;
      font-weight: 600;
      margin: 14px 0 8px;
      display: flex;
      align-items: center;
      gap: 6px;
      color: #111827;
    }

    .section-title:first-child {
      margin-top: 0;
    }

    .section-title small {
      font-weight: 400;
      font-size: 0.85rem;
      color: #6b7280;
    }

    pre {
      background: #0b1120;
      color: #e5e7eb;
      border-radius: 8px;
      padding: 12px 14px;
      font-size: 0.85rem;
      line-height: 1.4;
      max-height: 360px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    th,
    td {
      border-bottom: 1px solid #e5e7eb;
      padding: 8px 10px;
      text-align: left;
      vertical-align: top;
    }

    th {
      background: #f9fafb;
      font-weight: 600;
      width: 180px;
      white-space: nowrap;
    }

    td {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
        monospace;
      word-break: break-all;
    }

    .error {
      color: #b91c1c;
      font-size: 0.9rem;
      margin-top: 6px;
      white-space: pre-wrap;
    }

    .url-display {
      font-size: 0.85rem;
      color: #6b7280;
      word-break: break-all;
      margin-bottom: 6px;
    }

    /* Body type controls */
    .body-type-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .body-type-row label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: 400;
      cursor: pointer;
      padding: 6px 12px;
      border-radius: 6px;
      background: #f3f4f6;
      transition: background 0.15s;
    }

    .body-type-row label:hover {
      background: #e5e7eb;
    }

    .body-type-row input[type="radio"] {
      margin: 0;
      width: 18px;
      height: 18px;
    }

    .body-type-row input[type="radio"]:checked + span {
      font-weight: 600;
    }

    #json-body-container,
    #form-body-container,
    #headers-editor-container {
      margin-top: 10px;
    }

    #json-body,
    #curl-input {
      width: 100%;
      min-height: 100px;
      padding: 10px 12px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
        monospace;
    }

    #curl-input {
      min-height: 80px;
    }

    /* Key/value pair editor */
    .kv-pairs {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .kv-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .kv-row input[type="text"] {
      flex: 1;
      padding: 8px 12px;
      height: 44px;
    }

    .kv-row input[type="text"].kv-key {
      max-width: 200px;
    }

    .kv-row button {
      padding: 8px 12px;
      min-height: 44px;
      border-radius: 8px;
    }

    .add-pair-btn {
      align-self: flex-start;
      margin-top: 4px;
    }

    .hidden {
      display: none !important;
    }

    /* Curl import section */
    .curl-import-section {
      background: #faf5ff;
      border: 1px solid #e9d5ff;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 14px;
    }

    .curl-import-section label {
      color: #6b21a8;
    }

    .curl-import-section .hint {
      color: #7c3aed;
    }

    .curl-btn-row {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    /* Collapsible section */
    .collapsible-header {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
    }

    .collapsible-header .toggle-icon {
      font-size: 0.8rem;
      transition: transform 0.2s;
    }

    .collapsible-header.collapsed .toggle-icon {
      transform: rotate(-90deg);
    }

    .collapsible-content {
      overflow: hidden;
      transition: max-height 0.2s ease-out;
    }

    .collapsible-content.collapsed {
      max-height: 0 !important;
    }

    .header-count {
      background: #dbeafe;
      color: #1d4ed8;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    @media (max-width: 640px) {
      .card {
        padding: 14px 14px 16px;
      }

      .method-url-row {
        flex-direction: column;
      }

      #method-select {
        width: 100%;
      }

      #url-input {
        width: 100%;
      }

      button {
        width: 100%;
      }

      .curl-btn-row button {
        flex: 1;
      }

      .kv-row {
        flex-wrap: wrap;
      }

      .kv-row input[type="text"].kv-key {
        max-width: none;
      }

      .kv-row button {
        width: auto;
        flex-shrink: 0;
      }

      th {
        width: 120px;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <h1>CORS Fetch Tester</h1>
    <div class="subtitle">
      Send HTTP requests and inspect what the browser lets you see through CORS.
    </div>

    <!-- Request card -->
    <div class="card">
      <!-- Curl Import Section -->
      <div class="curl-import-section">
        <label for="curl-input">Import from curl</label>
        <textarea
          id="curl-input"
          placeholder="Paste a curl command here, e.g.:
curl -X POST 'https://api.example.com/data' \
  -H 'Content-Type: application/json' \
  -d '{&quot;key&quot;: &quot;value&quot;}'"
        ></textarea>
        <div class="curl-btn-row">
          <button type="button" class="accent" id="parse-curl-btn">Import curl</button>
          <button type="button" class="secondary" id="clear-curl-btn">Clear</button>
        </div>
        <div class="hint">Paste a curl command to auto-fill the form below.</div>
        <div id="curl-error" class="error" style="display:none;"></div>
      </div>

      <div class="section-title">Request</div>

      <label for="url-input">URL</label>
      <div class="method-url-row">
        <select id="method-select">
          <option value="GET">GET</option>
          <option value="POST">POST</option>
          <option value="PUT">PUT</option>
          <option value="PATCH">PATCH</option>
          <option value="DELETE">DELETE</option>
          <option value="HEAD">HEAD</option>
          <option value="OPTIONS">OPTIONS</option>
        </select>
        <input
          type="text"
          id="url-input"
          placeholder="https://example.com/api"
          autocomplete="off"
        />
      </div>

      <!-- Headers Section -->
      <div class="section-title collapsible-header" id="headers-toggle">
        <span class="toggle-icon">▼</span>
        Request Headers
        <span class="header-count" id="headers-count">0</span>
      </div>
      <div class="collapsible-content" id="headers-editor-container">
        <div id="headers-pairs" class="kv-pairs">
          <!-- Header key/value rows inserted here -->
        </div>
        <button type="button" class="secondary add-pair-btn" id="add-header-btn">+ Add header</button>
      </div>

      <label style="margin-top: 14px;">Request Body</label>
      <div class="body-type-row">
        <label>
          <input type="radio" name="body-type" value="none" checked />
          <span>None</span>
        </label>
        <label>
          <input type="radio" name="body-type" value="json" />
          <span>JSON</span>
        </label>
        <label>
          <input type="radio" name="body-type" value="form" />
          <span>Form (URL-encoded)</span>
        </label>
      </div>

      <div id="json-body-container" class="hidden">
        <textarea
          id="json-body"
          placeholder='{"key": "value"}'
        ></textarea>
        <div class="hint">Enter valid JSON for the request body.</div>
      </div>

      <div id="form-body-container" class="hidden">
        <div id="kv-pairs" class="kv-pairs">
          <!-- Key/value rows inserted here -->
        </div>
        <button type="button" class="secondary add-pair-btn" id="add-pair-btn">+ Add field</button>
      </div>

      <div class="input-row" style="margin-top: 14px;">
        <button id="fetch-btn">
          <span id="fetch-btn-spinner" class="spinner" style="display:none;"></span>
          <span id="fetch-btn-label">Send request</span>
        </button>
      </div>

      <div class="hint">
        If you omit the scheme, <code>https://</code> will be added.
        If CORS isn't enabled, the browser will block the response.
      </div>
      <div id="request-error" class="error" style="display:none;"></div>
    </div>

    <!-- Response card -->
    <div class="card">
      <div class="section-title">
        Response
        <small>(last request)</small>
      </div>
      <div id="effective-url" class="url-display"></div>
      <div class="status-row">
        <div id="status-pill" class="pill">No request yet</div>
        <div id="meta-pill" class="pill" style="display:none;"></div>
      </div>
      <div id="response-error" class="error" style="display:none;"></div>

      <div class="section-title">
        Headers
        <small>Only headers exposed by CORS are visible</small>
      </div>
      <div id="headers-container">
        <div class="hint">No headers yet.</div>
      </div>

      <div class="section-title">
        Body
        <small>Shown as text (UTF-8)</small>
      </div>
      <pre id="body-output">// Response body will appear here</pre>
    </div>
  </div>

  <script>
    const methodSelect = document.getElementById("method-select");
    const urlInput = document.getElementById("url-input");
    const fetchBtn = document.getElementById("fetch-btn");
    const fetchBtnLabel = document.getElementById("fetch-btn-label");
    const fetchBtnSpinner = document.getElementById("fetch-btn-spinner");

    const bodyTypeRadios = document.querySelectorAll('input[name="body-type"]');
    const jsonBodyContainer = document.getElementById("json-body-container");
    const jsonBodyTextarea = document.getElementById("json-body");
    const formBodyContainer = document.getElementById("form-body-container");
    const kvPairsContainer = document.getElementById("kv-pairs");
    const addPairBtn = document.getElementById("add-pair-btn");

    // Headers editor
    const headersPairsContainer = document.getElementById("headers-pairs");
    const addHeaderBtn = document.getElementById("add-header-btn");
    const headersToggle = document.getElementById("headers-toggle");
    const headersEditorContainer = document.getElementById("headers-editor-container");
    const headersCountEl = document.getElementById("headers-count");

    // Curl import
    const curlInput = document.getElementById("curl-input");
    const parseCurlBtn = document.getElementById("parse-curl-btn");
    const clearCurlBtn = document.getElementById("clear-curl-btn");
    const curlErrorEl = document.getElementById("curl-error");

    const requestErrorEl = document.getElementById("request-error");
    const responseErrorEl = document.getElementById("response-error");
    const statusPill = document.getElementById("status-pill");
    const metaPill = document.getElementById("meta-pill");
    const effectiveUrlEl = document.getElementById("effective-url");
    const headersContainer = document.getElementById("headers-container");
    const bodyOutput = document.getElementById("body-output");

    // State
    let kvPairs = [];
    let headerPairs = [];

    // Headers collapsible
    headersToggle.addEventListener("click", () => {
      headersToggle.classList.toggle("collapsed");
      headersEditorContainer.classList.toggle("collapsed");
    });

    function updateHeadersCount() {
      const count = headerPairs.filter(h => h.key.trim()).length;
      headersCountEl.textContent = count;
    }

    function getBodyType() {
      const checked = document.querySelector('input[name="body-type"]:checked');
      return checked ? checked.value : "none";
    }

    function setBodyType(type) {
      const radio = document.querySelector(`input[name="body-type"][value="${type}"]`);
      if (radio) {
        radio.checked = true;
        updateBodyVisibility();
      }
    }

    function updateBodyVisibility() {
      const bodyType = getBodyType();
      jsonBodyContainer.classList.toggle("hidden", bodyType !== "json");
      formBodyContainer.classList.toggle("hidden", bodyType !== "form");
    }

    bodyTypeRadios.forEach(radio => {
      radio.addEventListener("change", () => {
        updateBodyVisibility();
        updateFragmentFromState();
      });
    });

    // Generic key/value pair renderer
    function createKvPairRenderer(container, pairsArray, keyPlaceholder, valuePlaceholder, onUpdate) {
      return function renderPairs() {
        container.innerHTML = "";
        pairsArray.forEach((pair, index) => {
          const row = document.createElement("div");
          row.className = "kv-row";
          row.innerHTML = `
            <input type="text" class="kv-key" placeholder="${keyPlaceholder}" value="${escapeHtml(pair.key)}" data-index="${index}" />
            <input type="text" class="kv-value" placeholder="${valuePlaceholder}" value="${escapeHtml(pair.value)}" data-index="${index}" />
            <button type="button" class="danger remove-pair-btn" data-index="${index}">&times;</button>
          `;
          container.appendChild(row);
        });

        container.querySelectorAll(".kv-key").forEach(input => {
          input.addEventListener("input", (e) => {
            const idx = parseInt(e.target.dataset.index, 10);
            pairsArray[idx].key = e.target.value;
            onUpdate();
          });
        });

        container.querySelectorAll(".kv-value").forEach(input => {
          input.addEventListener("input", (e) => {
            const idx = parseInt(e.target.dataset.index, 10);
            pairsArray[idx].value = e.target.value;
            onUpdate();
          });
        });

        container.querySelectorAll(".remove-pair-btn").forEach(btn => {
          btn.addEventListener("click", (e) => {
            const idx = parseInt(e.target.dataset.index, 10);
            pairsArray.splice(idx, 1);
            renderPairs();
            onUpdate();
          });
        });
      };
    }

    // Form body pairs
    const renderKvPairs = createKvPairRenderer(
      kvPairsContainer,
      kvPairs,
      "Key",
      "Value",
      () => updateFragmentFromState()
    );

    // Header pairs
    const renderHeaderPairs = createKvPairRenderer(
      headersPairsContainer,
      headerPairs,
      "Header name",
      "Header value",
      () => {
        updateHeadersCount();
        updateFragmentFromState();
      }
    );

    function addKvPair(key = "", value = "") {
      kvPairs.push({ key, value });
      renderKvPairs();
    }

    function addHeaderPair(key = "", value = "") {
      headerPairs.push({ key, value });
      renderHeaderPairs();
      updateHeadersCount();
    }

    addPairBtn.addEventListener("click", () => {
      addKvPair();
      updateFragmentFromState();
    });

    addHeaderBtn.addEventListener("click", () => {
      addHeaderPair();
      updateFragmentFromState();
    });

    function initKvPairs() {
      if (kvPairs.length === 0) {
        kvPairs.push({ key: "", value: "" });
      }
      renderKvPairs();
    }

    function initHeaderPairs() {
      if (headerPairs.length === 0) {
        headerPairs.push({ key: "", value: "" });
      }
      renderHeaderPairs();
      updateHeadersCount();
    }

    // Curl parser
    function parseCurl(curlCommand) {
      // Normalize the command - join backslash-continued lines
      let normalized = curlCommand
        .replace(/\\\r?\n/g, " ")
        .replace(/\r?\n/g, " ")
        .trim();

      // Check if it starts with curl
      if (!normalized.match(/^curl\s/i)) {
        throw new Error("Command must start with 'curl'");
      }

      const result = {
        method: "GET",
        url: "",
        headers: [],
        body: null
      };

      // Tokenize respecting quotes
      const tokens = [];
      let current = "";
      let inSingleQuote = false;
      let inDoubleQuote = false;
      let escaped = false;

      for (let i = 0; i < normalized.length; i++) {
        const char = normalized[i];

        if (escaped) {
          current += char;
          escaped = false;
          continue;
        }

        if (char === "\\") {
          escaped = true;
          continue;
        }

        if (char === "'" && !inDoubleQuote) {
          inSingleQuote = !inSingleQuote;
          continue;
        }

        if (char === '"' && !inSingleQuote) {
          inDoubleQuote = !inDoubleQuote;
          continue;
        }

        if (char === " " && !inSingleQuote && !inDoubleQuote) {
          if (current) {
            tokens.push(current);
            current = "";
          }
          continue;
        }

        current += char;
      }
      if (current) {
        tokens.push(current);
      }

      // Helper to parse a header string
      function parseHeader(headerStr) {
        const colonIdx = headerStr.indexOf(":");
        if (colonIdx > 0) {
          const key = headerStr.substring(0, colonIdx).trim();
          const value = headerStr.substring(colonIdx + 1).trim();
          result.headers.push({ key, value });
        }
      }

      // Parse tokens
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];

        if (token === "curl") continue;

        // Method: -X POST or --request POST
        if (token === "-X" || token === "--request") {
          if (i + 1 < tokens.length) {
            result.method = tokens[++i].toUpperCase();
          }
          continue;
        }
        // Method: -XPOST (attached)
        if (token.startsWith("-X") && token.length > 2) {
          result.method = token.substring(2).toUpperCase();
          continue;
        }

        // Header: -H "..." or --header "..."
        if (token === "-H" || token === "--header") {
          if (i + 1 < tokens.length) {
            parseHeader(tokens[++i]);
          }
          continue;
        }
        // Header: -H"..." (attached)
        if (token.startsWith("-H") && token.length > 2) {
          parseHeader(token.substring(2));
          continue;
        }
        // Header: --header=...
        if (token.startsWith("--header=")) {
          parseHeader(token.substring(9));
          continue;
        }

        // Data: -d "..." or --data "..."
        if (token === "-d" || token === "--data" || token === "--data-raw" || token === "--data-binary") {
          if (i + 1 < tokens.length) {
            result.body = tokens[++i];
          }
          continue;
        }
        // Data: -d"..." or -d'...' (attached, quotes already stripped)
        if (token.startsWith("-d") && token.length > 2 && !token.startsWith("-d@")) {
          result.body = token.substring(2);
          continue;
        }
        // Data: --data=... or --data-raw=...
        if (token.startsWith("--data=")) {
          result.body = token.substring(7);
          continue;
        }
        if (token.startsWith("--data-raw=")) {
          result.body = token.substring(11);
          continue;
        }
        if (token.startsWith("--data-binary=")) {
          result.body = token.substring(14);
          continue;
        }

        // Skip @file references
        if (token.startsWith("-d@") || token.startsWith("--data=@")) {
          continue;
        }

        // Skip common flags we don't use
        if (token.match(/^-[kvsSLfIi]$/) ||
            token === "--compressed" ||
            token === "--location" ||
            token === "--insecure" ||
            token === "--silent" ||
            token === "--show-error" ||
            token === "--fail") {
          continue;
        }

        // Skip flags with values
        if (token === "-o" || token === "--output" ||
            token === "-u" || token === "--user" ||
            token === "-A" || token === "--user-agent" ||
            token === "--connect-timeout" ||
            token === "--max-time" ||
            token === "-m") {
          i++; // Skip the next token (the value)
          continue;
        }

        // URL - anything that looks like a URL or doesn't start with -
        if (!token.startsWith("-") && (token.includes("://") || token.includes(".") || token.startsWith("/"))) {
          result.url = token;
          continue;
        }
      }

      // If method is POST/PUT/PATCH and we have a body, that's good
      // If we have a body but method is GET, change to POST
      if (result.body && result.method === "GET") {
        result.method = "POST";
      }

      if (!result.url) {
        throw new Error("No URL found in curl command");
      }

      return result;
    }

    function applyCurlResult(parsed) {
      // Set method
      methodSelect.value = parsed.method;

      // Set URL
      urlInput.value = parsed.url;

      // Set headers
      headerPairs = parsed.headers.length > 0
        ? parsed.headers
        : [{ key: "", value: "" }];
      renderHeaderPairs();
      updateHeadersCount();

      // Expand headers if there are any
      if (parsed.headers.length > 0) {
        headersToggle.classList.remove("collapsed");
        headersEditorContainer.classList.remove("collapsed");
      }

      // Set body
      if (parsed.body) {
        // Check if it looks like JSON
        try {
          JSON.parse(parsed.body);
          setBodyType("json");
          jsonBodyTextarea.value = parsed.body;
        } catch {
          // Check if it looks like form data (key=value&key2=value2)
          if (parsed.body.includes("=") && !parsed.body.includes("{")) {
            setBodyType("form");
            const params = new URLSearchParams(parsed.body);
            kvPairs = [];
            for (const [key, value] of params) {
              kvPairs.push({ key, value });
            }
            if (kvPairs.length === 0) {
              kvPairs.push({ key: "", value: "" });
            }
            renderKvPairs();
          } else {
            // Treat as JSON anyway
            setBodyType("json");
            jsonBodyTextarea.value = parsed.body;
          }
        }
      } else {
        setBodyType("none");
      }

      updateFragmentFromState();
    }

    parseCurlBtn.addEventListener("click", () => {
      curlErrorEl.style.display = "none";
      const curlCmd = curlInput.value.trim();
      if (!curlCmd) {
        curlErrorEl.textContent = "Please paste a curl command first.";
        curlErrorEl.style.display = "block";
        return;
      }

      try {
        const parsed = parseCurl(curlCmd);
        applyCurlResult(parsed);
        curlInput.value = ""; // Clear after successful import
      } catch (e) {
        curlErrorEl.textContent = "Failed to parse curl: " + e.message;
        curlErrorEl.style.display = "block";
      }
    });

    clearCurlBtn.addEventListener("click", () => {
      curlInput.value = "";
      curlErrorEl.style.display = "none";
    });

    // Auto-parse on paste
    curlInput.addEventListener("paste", (e) => {
      // Use setTimeout to let the paste complete first
      setTimeout(() => {
        const curlCmd = curlInput.value.trim();
        if (curlCmd && curlCmd.match(/^curl\s/i)) {
          try {
            const parsed = parseCurl(curlCmd);
            applyCurlResult(parsed);
            curlInput.value = "";
            curlErrorEl.style.display = "none";
          } catch (e) {
            // Don't show error on auto-parse, let user click the button
          }
        }
      }, 0);
    });

    function setLoading(isLoading) {
      fetchBtn.disabled = isLoading;
      fetchBtnSpinner.style.display = isLoading ? "inline-block" : "none";
      fetchBtnLabel.textContent = isLoading ? "Loading…" : "Send request";
    }

    function setStatus(text, ok, extraMeta) {
      statusPill.textContent = text;
      statusPill.classList.remove("status-ok", "status-error");

      if (ok === true) {
        statusPill.classList.add("status-ok");
      } else if (ok === false) {
        statusPill.classList.add("status-error");
      }

      if (extraMeta) {
        metaPill.style.display = "inline-block";
        metaPill.textContent = extraMeta;
      } else {
        metaPill.style.display = "none";
      }
    }

    function clearErrors() {
      requestErrorEl.style.display = "none";
      requestErrorEl.textContent = "";
      responseErrorEl.style.display = "none";
      responseErrorEl.textContent = "";
    }

    function renderResponseHeaders(headers) {
      const entries = [];
      headers.forEach((value, key) => {
        entries.push({ key, value });
      });

      if (entries.length === 0) {
        headersContainer.innerHTML =
          '<div class="hint">No headers visible. The server may not be exposing any CORS-readable headers.</div>';
        return;
      }

      let html = "<table><thead><tr><th>Header</th><th>Value</th></tr></thead><tbody>";
      for (const { key, value } of entries) {
        html +=
          "<tr><th>" +
          escapeHtml(key) +
          "</th><td>" +
          escapeHtml(value) +
          "</td></tr>";
      }
      html += "</tbody></table>";
      headersContainer.innerHTML = html;
    }

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function normalizeUrl(raw) {
      const trimmed = raw.trim();
      if (!trimmed) return "";

      if (!/^https?:\/\//i.test(trimmed)) {
        return "https://" + trimmed;
      }

      return trimmed;
    }

    function buildRequestHeaders() {
      const headers = {};
      for (const pair of headerPairs) {
        if (pair.key.trim()) {
          headers[pair.key.trim()] = pair.value;
        }
      }
      return headers;
    }

    function buildRequestBody() {
      const bodyType = getBodyType();

      if (bodyType === "none") {
        return { body: null, contentType: null };
      }

      if (bodyType === "json") {
        const jsonText = jsonBodyTextarea.value.trim();
        if (!jsonText) {
          return { body: null, contentType: null };
        }
        try {
          JSON.parse(jsonText);
        } catch (e) {
          throw new Error("Invalid JSON: " + e.message);
        }
        return { body: jsonText, contentType: "application/json" };
      }

      if (bodyType === "form") {
        const params = new URLSearchParams();
        let hasData = false;
        for (const pair of kvPairs) {
          if (pair.key.trim()) {
            params.append(pair.key, pair.value);
            hasData = true;
          }
        }
        if (!hasData) {
          return { body: null, contentType: null };
        }
        return { body: params.toString(), contentType: "application/x-www-form-urlencoded" };
      }

      return { body: null, contentType: null };
    }

    async function doFetch() {
      clearErrors();
      const rawUrl = urlInput.value;
      const url = normalizeUrl(rawUrl);
      const method = methodSelect.value;

      if (!url) {
        requestErrorEl.textContent = "Please enter a URL.";
        requestErrorEl.style.display = "block";
        return;
      }

      try {
        new URL(url);
      } catch (e) {
        requestErrorEl.textContent = "That doesn't look like a valid URL.";
        requestErrorEl.style.display = "block";
        return;
      }

      let reqBody, contentType;
      try {
        const bodyResult = buildRequestBody();
        reqBody = bodyResult.body;
        contentType = bodyResult.contentType;
      } catch (e) {
        requestErrorEl.textContent = e.message;
        requestErrorEl.style.display = "block";
        return;
      }

      setLoading(true);
      setStatus("Pending request…", null);
      effectiveUrlEl.textContent = "";
      headersContainer.innerHTML = '<div class="hint">Awaiting response…</div>';
      bodyOutput.textContent = "";

      updateFragmentFromState();

      try {
        const fetchOptions = {
          method: method,
          mode: "cors",
        };

        // Build headers
        const reqHeaders = buildRequestHeaders();

        // Add content-type if we have a body and it's not already set
        if (reqBody && !["GET", "HEAD"].includes(method)) {
          fetchOptions.body = reqBody;
          if (contentType && !Object.keys(reqHeaders).some(k => k.toLowerCase() === "content-type")) {
            reqHeaders["Content-Type"] = contentType;
          }
        }

        if (Object.keys(reqHeaders).length > 0) {
          fetchOptions.headers = reqHeaders;
        }

        const response = await fetch(url, fetchOptions);

        const statusText = `${response.status} ${response.statusText}`;
        setStatus(statusText, response.ok, response.type.toUpperCase());

        effectiveUrlEl.textContent = "Effective URL: " + response.url;

        renderResponseHeaders(response.headers);

        if (method === "HEAD") {
          bodyOutput.textContent = "// HEAD requests do not return a body.";
        } else {
          let bodyText;
          try {
            bodyText = await response.text();
          } catch (e) {
            bodyText = "// Could not read body as text.\n// Error: " + String(e);
          }

          if (!bodyText) {
            bodyOutput.textContent = "// Empty response body (or body already consumed).";
          } else {
            bodyOutput.textContent = bodyText;
          }
        }
      } catch (err) {
        setStatus("Request failed", false, "NETWORK / CORS ERROR");
        responseErrorEl.style.display = "block";
        responseErrorEl.textContent =
          "The request failed. In a browser, this is often due to CORS or network issues.\n\n" +
          "Error: " +
          String(err);
        headersContainer.innerHTML =
          '<div class="hint">No headers: the browser blocked access to the response.</div>';
        bodyOutput.textContent =
          "// No body: the browser blocked access to the response.\n" +
          "// This usually means the server has not enabled CORS for this origin.";
      } finally {
        setLoading(false);
      }
    }

    // Fragment URL state management
    function getStateForFragment() {
      return {
        method: methodSelect.value,
        url: urlInput.value,
        bodyType: getBodyType(),
        jsonBody: jsonBodyTextarea.value,
        formPairs: kvPairs.filter(p => p.key.trim() || p.value.trim()),
        headers: headerPairs.filter(h => h.key.trim() || h.value.trim())
      };
    }

    function encodeStateToFragment(state) {
      const params = new URLSearchParams();
      if (state.method && state.method !== "GET") {
        params.set("method", state.method);
      }
      if (state.url) {
        params.set("url", state.url);
      }
      if (state.bodyType && state.bodyType !== "none") {
        params.set("bodyType", state.bodyType);
      }
      if (state.bodyType === "json" && state.jsonBody) {
        params.set("json", state.jsonBody);
      }
      if (state.bodyType === "form" && state.formPairs && state.formPairs.length > 0) {
        params.set("form", JSON.stringify(state.formPairs));
      }
      if (state.headers && state.headers.length > 0) {
        params.set("headers", JSON.stringify(state.headers));
      }
      return params.toString();
    }

    function decodeStateFromFragment(fragment) {
      const params = new URLSearchParams(fragment);
      return {
        method: params.get("method") || "GET",
        url: params.get("url") || "",
        bodyType: params.get("bodyType") || "none",
        jsonBody: params.get("json") || "",
        formPairs: params.has("form") ? JSON.parse(params.get("form")) : [],
        headers: params.has("headers") ? JSON.parse(params.get("headers")) : []
      };
    }

    function updateFragmentFromState() {
      const state = getStateForFragment();
      const fragment = encodeStateToFragment(state);
      if (fragment) {
        history.replaceState(null, "", "#" + fragment);
      } else {
        history.replaceState(null, "", window.location.pathname + window.location.search);
      }
    }

    function loadStateFromFragment() {
      const hash = window.location.hash.slice(1);
      if (!hash) return false;

      try {
        const state = decodeStateFromFragment(hash);

        methodSelect.value = state.method;
        urlInput.value = state.url;
        setBodyType(state.bodyType);
        jsonBodyTextarea.value = state.jsonBody;

        if (state.formPairs && state.formPairs.length > 0) {
          kvPairs = state.formPairs;
        } else {
          kvPairs = [{ key: "", value: "" }];
        }
        renderKvPairs();

        if (state.headers && state.headers.length > 0) {
          headerPairs = state.headers;
          // Expand headers section if there are headers
          headersToggle.classList.remove("collapsed");
          headersEditorContainer.classList.remove("collapsed");
        } else {
          headerPairs = [{ key: "", value: "" }];
        }
        renderHeaderPairs();
        updateHeadersCount();

        return true;
      } catch (e) {
        console.warn("Failed to parse URL fragment state:", e);
        return false;
      }
    }

    function loadStateFromQueryParam() {
      const params = new URLSearchParams(window.location.search);
      const urlParam = params.get("url");
      if (urlParam) {
        urlInput.value = urlParam;
        return true;
      }
      return false;
    }

    // Event listeners
    fetchBtn.addEventListener("click", doFetch);

    urlInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        doFetch();
      }
    });

    urlInput.addEventListener("input", updateFragmentFromState);
    methodSelect.addEventListener("change", updateFragmentFromState);
    jsonBodyTextarea.addEventListener("input", updateFragmentFromState);

    // Initialize
    initKvPairs();
    initHeaderPairs();

    // Load state from URL on page load (but don't auto-execute)
    const loadedFromFragment = loadStateFromFragment();
    if (!loadedFromFragment) {
      loadStateFromQueryParam();
    }
  </script>
</body>
</html>
