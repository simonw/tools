<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pyodide REPL</title>
    <link
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêç</text></svg>"
      rel="icon"
    />
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        :root {
            --bg: #1a1a2e;
            --surface: #16213e;
            --output-bg: #0f0f1a;
            --text: #e0e0e0;
            --muted: #8888aa;
            --accent: #4fc3f7;
            --accent-hover: #81d4fa;
            --prompt-color: #4fc3f7;
            --error-color: #ef5350;
            --border: rgba(255,255,255,0.1);
            --mono: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
        }
        html, body {
            height: 100%;
            background: var(--output-bg);
            color: var(--text);
            font-family: var(--mono);
            font-size: 14px;
        }
        #scroll-container {
            height: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        #header {
            padding: 12px 16px 8px;
            border-bottom: 1px solid var(--border);
            background: var(--bg);
        }
        #header h1 {
            font-size: 16px;
            font-weight: 600;
            color: var(--accent);
        }
        #header .subtitle {
            font-size: 12px;
            color: var(--muted);
            margin-top: 2px;
        }
        #output {
            padding: 12px 16px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
        }
        #output .banner { color: var(--muted); }
        #output .prompt { color: var(--prompt-color); }
        #output .input-echo { color: var(--text); }
        #output .stdout { color: var(--text); }
        #output .stderr { color: var(--error-color); }

        /* Input area flows inline after output */
        #input-area {
            padding: 16px 16px 16px;
        }
        #input-row {
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }
        #prompt-label {
            color: var(--prompt-color);
            font-weight: bold;
            padding: 9px 0 0 0;
            flex-shrink: 0;
            line-height: 1.5;
        }
        #input-wrap {
            flex: 1;
            min-width: 0;
        }
        #input {
            width: 100%;
            background: var(--surface);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 10px;
            font-family: var(--mono);
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            overflow: hidden;
        }
        #input.multiline {
            min-height: 100px;
            resize: vertical;
            overflow: auto;
        }
        #input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(79, 195, 247, 0.2);
        }
        #input::placeholder {
            color: var(--muted);
        }
        #btn-row {
            display: flex;
            gap: 6px;
            margin-top: 6px;
        }
        #run-btn {
            background: var(--accent);
            color: #000;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            font-family: var(--mono);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            touch-action: manipulation;
        }
        #run-btn:hover { background: var(--accent-hover); }
        #run-btn:active { transform: scale(0.97); }
        #run-btn:disabled { opacity: 0.5; cursor: default; }
        #mode-btn {
            background: transparent;
            color: var(--muted);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 10px;
            font-family: var(--mono);
            font-size: 12px;
            cursor: pointer;
            touch-action: manipulation;
            white-space: nowrap;
        }
        #mode-btn:hover { color: var(--text); border-color: var(--muted); }
        #mode-btn:active { transform: scale(0.97); }
        .mode-hint {
            font-size: 11px;
            color: var(--muted);
            margin-left: auto;
            padding: 8px 0;
            white-space: nowrap;
        }

        /* Bottom padding so content isn't hidden behind keyboard */
        #bottom-spacer {
            height: 40vh;
        }

        #loading-overlay {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            gap: 16px;
        }
        #loading-overlay.hidden { display: none; }
        .spinner {
            width: 36px;
            height: 36px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loading-text {
            color: var(--muted);
            font-size: 14px;
        }
        @media (max-width: 600px) {
            #header { padding: 10px 12px 6px; }
            #output { padding: 10px 12px 0; font-size: 13px; }
            #input-area { padding: 0 12px 12px; }
            #input { font-size: 16px; /* prevents iOS zoom */ }
            #run-btn { padding: 8px 12px; }
            #prompt-label { padding: 7px 0 0 0; }
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">Loading Pyodide...</div>
    </div>

    <div id="scroll-container">
        <div id="header">
            <h1>Pyodide REPL</h1>
            <div class="subtitle">Python in the browser &mdash; mobile friendly</div>
        </div>

        <div id="output"></div>

        <div id="input-area">
            <div id="input-row">
                <div id="prompt-label">&gt;&gt;&gt;</div>
                <div id="input-wrap">
                    <textarea id="input" rows="1" placeholder="Python code..." autocapitalize="none" autocomplete="off" autocorrect="off" spellcheck="false"></textarea>
                    <div id="btn-row">
                        <button id="run-btn" disabled>Run</button>
                        <button id="mode-btn">Multi-line</button>
                        <div class="mode-hint" id="mode-hint">Enter to run</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="bottom-spacer"></div>
    </div>

    <script type="module">
        const scrollContainer = document.getElementById('scroll-container');
        const outputEl = document.getElementById('output');
        const inputEl = document.getElementById('input');
        const inputArea = document.getElementById('input-area');
        const runBtn = document.getElementById('run-btn');
        const modeBtn = document.getElementById('mode-btn');
        const modeHint = document.getElementById('mode-hint');
        const promptLabel = document.getElementById('prompt-label');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');

        let pyodide = null;
        let pyconsole = null;
        let reprShorten = null;
        let awaitFut = null;
        let currentPrompt = '>>> ';
        let running = false;
        let multilineMode = false;

        // History
        const history = [];
        let historyIndex = -1;

        function appendOutput(text, cls) {
            const span = document.createElement('span');
            span.className = cls;
            span.textContent = text;
            outputEl.appendChild(span);
            scrollToInput();
        }

        function scrollToInput() {
            // Scroll so the input area is visible
            requestAnimationFrame(() => {
                inputArea.scrollIntoView({ block: 'nearest', behavior: 'auto' });
            });
        }

        function setPrompt(ps) {
            currentPrompt = ps;
            promptLabel.textContent = ps;
        }

        function autoResize() {
            if (multilineMode) return; // manual resize in multiline mode
            inputEl.style.height = 'auto';
            inputEl.style.height = inputEl.scrollHeight + 'px';
        }

        function setMode(multi) {
            multilineMode = multi;
            if (multi) {
                inputEl.classList.add('multiline');
                inputEl.style.height = '';
                modeBtn.textContent = 'Single-line';
                modeHint.textContent = 'Ctrl+Enter to run';
            } else {
                inputEl.classList.remove('multiline');
                modeBtn.textContent = 'Multi-line';
                modeHint.textContent = 'Enter to run';
                autoResize();
            }
            inputEl.focus();
        }

        modeBtn.addEventListener('click', () => setMode(!multilineMode));

        inputEl.addEventListener('input', autoResize);

        // Run a single line through PyodideConsole
        async function pushLine(line) {
            const fut = pyconsole.push(line);
            const syntaxCheck = fut.syntax_check;

            if (syntaxCheck === 'incomplete') {
                setPrompt('... ');
                fut.destroy();
                return 'incomplete';
            }

            setPrompt('>>> ');

            if (syntaxCheck === 'syntax-error') {
                const err = fut.formatted_error.trimEnd();
                appendOutput(err + '\n', 'stderr');
                fut.destroy();
                return 'error';
            }

            // complete - evaluate
            const wrapped = awaitFut(fut);
            try {
                const [value] = await wrapped;
                if (value !== undefined) {
                    const repr = reprShorten.callKwargs(value, {
                        separator: '\n<long output truncated>\n',
                    });
                    appendOutput(repr + '\n', 'stdout');
                }
                if (value instanceof pyodide.ffi.PyProxy) {
                    value.destroy();
                }
            } catch (e) {
                if (e.constructor.name === 'PythonError') {
                    const message = fut.formatted_error || e.message;
                    appendOutput(message.trimEnd() + '\n', 'stderr');
                } else {
                    appendOutput(String(e) + '\n', 'stderr');
                }
            } finally {
                fut.destroy();
                wrapped.destroy();
            }
            return 'complete';
        }

        async function execute() {
            if (running || !pyconsole) return;

            const code = inputEl.value;
            if (!code && currentPrompt === '>>> ') return;

            running = true;
            runBtn.disabled = true;

            // Add to history (only for non-empty, non-continuation lines)
            if (code.trim() && currentPrompt === '>>> ') {
                history.push(code);
            }
            historyIndex = -1;

            const lines = code.split('\n');

            inputEl.value = '';
            autoResize();

            // Echo and process each line
            let lastResult;
            for (const line of lines) {
                appendOutput(currentPrompt, 'prompt');
                appendOutput(line + '\n', 'input-echo');
                const escaped = line.replaceAll(/\u00a0/g, ' ');
                lastResult = await pushLine(escaped);
            }
            // If still incomplete after all lines, push empty line to finish the block
            if (lastResult === 'incomplete') {
                await pushLine('');
            }

            running = false;
            runBtn.disabled = false;
            inputEl.focus();
            scrollToInput();
        }

        runBtn.addEventListener('click', execute);

        inputEl.addEventListener('keydown', (e) => {
            if (multilineMode) {
                // Multi-line mode: Ctrl/Cmd+Enter runs, Enter inserts newline
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    execute();
                    return;
                }
                // Tab: insert spaces
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = inputEl.selectionStart;
                    const end = inputEl.selectionEnd;
                    inputEl.value = inputEl.value.substring(0, start) + '    ' + inputEl.value.substring(end);
                    inputEl.selectionStart = inputEl.selectionEnd = start + 4;
                    return;
                }
                return;
            }

            // Single-line mode: Enter runs, Shift+Enter inserts newline
            if (e.key === 'Enter' && e.shiftKey) {
                return; // default behavior inserts newline
            }
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                execute();
                return;
            }
            // Tab: insert spaces
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = inputEl.selectionStart;
                const end = inputEl.selectionEnd;
                inputEl.value = inputEl.value.substring(0, start) + '    ' + inputEl.value.substring(end);
                inputEl.selectionStart = inputEl.selectionEnd = start + 4;
                autoResize();
                return;
            }
            // History navigation (only when single-line content)
            if (e.key === 'ArrowUp' && inputEl.value.indexOf('\n') === -1 && history.length > 0) {
                e.preventDefault();
                if (historyIndex === -1) historyIndex = history.length;
                if (historyIndex > 0) {
                    historyIndex--;
                    inputEl.value = history[historyIndex];
                    autoResize();
                }
                return;
            }
            if (e.key === 'ArrowDown' && inputEl.value.indexOf('\n') === -1 && historyIndex !== -1) {
                e.preventDefault();
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    inputEl.value = history[historyIndex];
                } else {
                    historyIndex = -1;
                    inputEl.value = '';
                }
                autoResize();
                return;
            }
        });

        // Initialize
        async function init() {
            try {
                loadingText.textContent = 'Loading Pyodide runtime...';
                const indexURL = 'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/';
                const { loadPyodide } = await import(indexURL + 'pyodide.mjs');

                loadingText.textContent = 'Initializing Python...';
                pyodide = await loadPyodide({
                    indexURL,
                    stdin: () => {
                        const result = prompt('stdin:');
                        return result ?? '';
                    },
                });
                globalThis.pyodide = pyodide;

                const imports = pyodide.pyimport('pyodide.console');
                reprShorten = imports.repr_shorten;
                const BANNER = imports.BANNER;
                const PyodideConsole = imports.PyodideConsole;

                pyconsole = PyodideConsole(pyodide.globals);

                // Set up await_fut helper
                const namespace = pyodide.globals.get('dict')();
                awaitFut = pyodide.runPython(`
import builtins
from pyodide.ffi import to_js

async def await_fut(fut):
    res = await fut
    if res is not None:
        builtins._ = res
    return to_js([res], depth=1)

await_fut
`, { globals: namespace });
                namespace.destroy();

                // Capture stdout/stderr
                pyconsole.stdout_callback = (s) => appendOutput(s, 'stdout');
                pyconsole.stderr_callback = (s) => appendOutput(s, 'stderr');

                // Show banner
                const bannerText = `Welcome to Pyodide ${pyodide.version} REPL\n` + BANNER +
                    '\nEnter Python code below. Enter to run, Shift+Enter for newline.\n\n';
                appendOutput(bannerText, 'banner');

                // Ready
                loadingOverlay.classList.add('hidden');
                runBtn.disabled = false;
                inputEl.focus();
            } catch (e) {
                loadingText.textContent = 'Failed to load: ' + e.message;
                console.error(e);
            }
        }

        init();
    </script>
</body>
</html>
